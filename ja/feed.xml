<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ja" /><updated>2025-03-31T07:15:17+00:00</updated><id>/feed.xml</id><title type="html">ILYBA</title><subtitle>Développement d&apos;applications Web et mobile</subtitle><entry><title type="html">コードの品質を測定し、保証するための基準とは？</title><link href="/bonnes-pratiques/ruby/rails/architecture/d%C3%A9veloppement/2025/03/31/crit%C3%A8res-pour-un-code-de-qualit%C3%A9.html" rel="alternate" type="text/html" title="コードの品質を測定し、保証するための基準とは？" /><published>2025-03-31T07:00:00+00:00</published><updated>2025-03-31T07:00:00+00:00</updated><id>/bonnes-pratiques/ruby/rails/architecture/d%C3%A9veloppement/2025/03/31/crit%C3%A8res-pour-un-code-de-qualit%C3%A9</id><content type="html" xml:base="/bonnes-pratiques/ruby/rails/architecture/d%C3%A9veloppement/2025/03/31/crit%C3%A8res-pour-un-code-de-qualit%C3%A9.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>私のキャリアの中で、初心者の開発者と経験豊富な開発者がコードの書き方や品質に対してどのようにアプローチするかに大きな違いがあることに気付きました。初心者は特定の目的に集中しますが、経験豊富な開発者は、さまざまなパラメータを考慮したより広いアプローチを取ります。</p>

<p>この記事では、グローバルなアプローチを採用し、測定可能な基準を使用して、どのように開発の品質を向上させるかを説明します。</p>

<h1 id="グローバルアプローチ">グローバルアプローチ</h1>

<p>キャリアの初期段階では、最も重要なのは主要な結果を得ることができるコードを作成することです。これは論理的ですが、実際には、期待される結果を得ることは思ったほど重要ではありません。むしろそれは二次的なものです…</p>

<p>実際、コードの最初のバージョンがうまく動作しないことは非常に一般的です。最終的にはコードを機能させる必要がありますが、それは修正するのが最も難しい部分ではありません。</p>

<p>一方で、コードの最初の試行に構造的な問題があり、変数名やメソッド名が不明瞭で、ベストプラクティスに従っていない場合、後々問題が発生する可能性が非常に高くなります。</p>

<p>だからこそ、経験豊富な開発者は、仕様のいくつかの詳細を確認し、確認し、再検討することに多くの努力を費やします。仕様がニーズに最も効果的に応える方法に沿って記述されているかどうかを確認します。その後、さまざまな技術的アプローチを模索し、最も適切なものを選択し、コードのアーキテクチャ、概念の命名規則、さまざまなユースケース、ソリューションがアプリケーションの他の部分に与える影響、エラーハンドリングのケースなどについて考えます。このリストは決して網羅的ではありません…</p>

<p>これらの側面についての思索が終わった後に初めて、純粋に機能的な側面に集中することになります。</p>

<p>このアプローチの利点は、長期的にメンテナンスがしやすいコードを生産することです。この利点には代償もあります。開発に必要な努力と時間は長くなります。これは短期的には不利ですが、すべての側面を考慮することで、バグのリスクを減らすことができ、明確で適切な命名規則を持つよく構造化されたコードは、コードの読みやすさを向上させ、適切な抽象レベルの使用は機能追加や変更を容易にします。</p>

<p>言い換えれば、コードに一気に取り掛かるほうが速いですが、このアプローチは後にバグ、パフォーマンスの問題、アプリケーションの進化の難しさという形で支払われることになります。</p>

<p>では、コードがメンテナンスしやすいかどうかを決定する要因は何でしょうか？</p>

<h1 id="仕様書の段階">仕様書の段階</h1>

<p>再び、仕様書の段階に注目しましょう。これらのドキュメントはしばしば軽視され、開発の中で時間がかかる割に価値が少ないと見なされがちです。</p>

<p>しかし、良く書かれた仕様書は次のことを防ぐことができます：</p>

<ul>
  <li><strong>納品が不適合であること。</strong> 例えば、あいまいな表現が原因で、開発者が仕様書を作成者の意図通りに解釈できなかった場合があります。または、ドキュメントが長く複雑すぎて、開発者が一部の詳細を見落とすこともあります。</li>
  <li><strong>納品が適合しているが、実際のニーズに合わないこと。</strong> 例えば、インターフェースの選定ミスが考えられます。</li>
  <li><strong>設計やパフォーマンスの技術的問題。</strong> たとえ機能的な仕様書であっても、将来のニーズを予測していなかった場合、アーキテクチャの選択が後々問題を引き起こす可能性があります。</li>
</ul>

<p>仕様書を上手に書くためには、もちろん十分な経験が役立ちますが、しばしばそれだけでは不十分です。ドキュメントは、発注者と技術チームの両方でレビューされ、議論されるべきです。これらの議論がきちんと行われると、開発の品質に大きな影響を与えることになります。</p>

<p>私の経験では、常に同じ傾向を見てきました。最初は仕様書が軽視され、バグや矛盾（ある変更が別の機能やユースケースを壊す場合）で苦しんでいるうちに、仕様書の質を向上させるための努力（プロダクトオーナーの採用、レビュープロセスの追加など）が行われます。そして、必ず改善が見られますが、それでもすべての問題を解決するには至りません。</p>

<h2 id="仕様書作成のアドバイス">仕様書作成のアドバイス</h2>

<p>良い仕様書を作成するために、私の方法は時間とともに大きく進化しました。普遍的な方法はありません。ある人はこの方法を面倒だと感じ、他の人は不十分だと感じるでしょう。それは、あなたがどれだけのコストをかける準備ができているか、または視点に応じて受け入れられる影響によって異なります。私が主に使用する形式は、ユーザーストーリーとバグ報告の2つです。ほとんどのタスクは、この2つの形式のいずれかで記述できます。</p>

<h2 id="ユーザーストーリー">ユーザーストーリー</h2>

<p>まず、タイトルは明確で以下の要素をきちんと記述する必要があります：</p>

<ul>
  <li><strong>アクター：</strong> アクターは開発の主な受益者です。</li>
  <li><strong>アクション：</strong> 開発の主要な目的です。</li>
  <li><strong>目標/利益：</strong> アクションの実行によって得られる結果です。これは、アクターがアクションから得る利益に対応する場合があります。しばしば軽視されがちですが、開発の有用性を確認するために非常に重要です。目標が難しい場合、それは機能が実際には有用でない可能性があることを示しているかもしれません。</li>
</ul>

<p>私が使うテンプレートは次の通りです： **<アクター>** として、私は **<アクション>** をしたい、**<目標>** のために。</目標></アクション></アクター></p>

<p>例：<strong>顧客</strong> として、私は <strong>自分の注文リストを確認したい</strong> 、<strong>購入履歴を知り、サポートセンターの負担を軽減するため</strong>。</p>

<p>次に、私は執筆を3つのセクションに分けます：</p>

<ul>
  <li><strong>コンテキスト：</strong> 仕様書の目的を明確にするいくつかの文。執筆する際には、現在の状況と解決すべき問題を説明することができます。
前述の例を使うと：サポートセンターには、顧客が注文履歴を知りたいという多くのリクエストがありますが、この機能はアプリケーションに存在しません。</li>
  <li><strong>説明：</strong> これは、期待される結果をできるだけ正確に記述する部分です。プロジェクトや開発者の経験に応じて、このセクションには実装の詳細も含まれる場合がありますが、私は個人的には、技術的な詳細についてはできるだけ開発者に自由度を持たせるようにしています。</li>
  <li><strong>受け入れ基準：</strong> このセクションは非常に重要です。時には、説明の再定義になります。これにより、開発者は仕様書を正しく理解したかどうかを確認し、品質管理チームが納品時に拒否を避けるための基準を持つことができます。また、品質管理チームは、機能を検証するための作業基盤を持つことができます。</li>
</ul>

<p>すべてのタスクに関して、これらのセクションに加えて、優先度を設定します。</p>

<h2 id="バグ報告">バグ報告</h2>

<p>良いバグ報告は、問題の修正を遅らせる誤解を避けるのに役立ちます。</p>

<p>タイトルは、問題を簡潔かつ正確に説明する必要があります。</p>

<p>例えば：メインページで、Enterキーを押しても検索が開始されません。</p>

<p>執筆時には、フラストレーションのあまり「リグレッション」という言葉を使いたくなるかもしれません。しかし、この言葉は報告書に明確に記録する場合を除き、避けるべきです（例えば、2つの異なるバージョンのアプリケーションで同じテストを行った場合など）。実際、多くの場合、この表現は不正確であるか、微妙にニュアンスが必要で、開発チームに「また壊しましたね」と伝えるネガティブなメッセージを送ってしまいます。これにより、職場の雰囲気が不必要に悪化します。</p>

<p>私のアドバイスは：実際にリグレッションがある場合でも、タイトルにその言葉を使うのは避け、本文で詳細を追加する方が良いです。代わりに、チケットに優先度を設定することができます。</p>

<p>報告書の本文は次の3つの部分で構成されます：</p>

<ul>
  <li><strong>再現手順：</strong> 問題を再現するための非常に詳細な手順。</li>
  <li><strong>期待される結果</strong></li>
  <li><strong>観察された結果</strong></li>
</ul>

<h1 id="開発段階">開発段階</h1>

<p>開発段階では、以下のアドバイスを参考にして、開発の品質を向上させてください：</p>

<ul>
  <li>先ほども述べたように、グローバルなアプローチを取ってください。機能のすべての側面を考慮し、目的だけに集中しないようにしてください。その他の機能への影響、将来の進化、可読性、メンテナンス性なども考慮してください。</li>
  <li>コードの構造について十分に考える時間を取ってください。単純化が必要か、逆に追加の抽象レベルを加えるべきかを自問してください。</li>
  <li>できる限りベストプラクティスを適用してください。特に、KISS（<em>Keep It Simple and Stupid</em> - コードはシンプルに保つ）、YAGNI（<em>You Are not Gonna Need It</em> - 必要ないことはしない）、SRP（<em>Single Responsibility Principle</em> - 単一責任の原則）、DRY（<em>Do not Repeat Yourself</em> - 繰り返しを避ける）、車輪を再発明しない（<a href="https://blog.codinghorror.com/dont-reinvent-the-wheel-unless-you-plan-on-learning-more-about-wheels/">車輪について学びたければ</a>）など。</li>
  <li>パフォーマンスや最適化の面を考慮してください。SQLクエリは効率的ですか？ アルゴリズム的な問題はありませんか？</li>
  <li>ドキュメントについても考慮してください。常に必要というわけではありませんが、必要なときには書かなければなりません。存在する場合は、最新の状態に保つ必要があります。</li>
  <li>リンターを使用して、コードベースを均一にし、構造的な問題（複雑すぎるコードや良いプラクティスを守らないなど）を防ぎます。個人的には、Rubocopのすべてのデフォルトルールを使い、erb-lintのオプションルールのほとんどを有効にしています。</li>
  <li>自動化されたテストを追加し、バグ修正のためには非リグレッションテストを作成してください。</li>
</ul>

<h1 id="開発の品質を測定する指標">開発の品質を測定する指標</h1>

<p>これで、仕様書や開発の改善方法について私のアドバイスを知っていただきました。しかし、私にとってうまくいったことが、あなたにも効果的であるとは限りません。幸いなことに、これらを盲目的に適用する必要はありません。今からは、あなたの環境で品質の進捗を測るために使用する基準について見ていきます。</p>

<p>これらのアドバイスの導入には一定の努力が必要です。プロセス変更による進化と、チームのスキル向上やその他のプロセスの進化などの要因を区別することは難しいでしょう。いくつかの指標を追跡することで、最も効果的な手法を正確に特定することはできませんが、進捗を評価し、その結果に基づいて意思決定を調整するのに役立ちます。</p>

<p>以下は、あなたの開発品質を測るために追跡できる指標です：</p>

<ul>
  <li>アプリケーション内のエラーの数</li>
  <li>単位時間あたりに納品されたタスクの数（スクラムのポイントは直接使用しないでください。タスク数の方が信頼性が高く、副作用もありません）。</li>
  <li>スクラムのポイントの分布（与えられたポイント数のタスクの割合）。この指標は前述の指標を補完します（納品されたタスク数が増加しているが、チームがテーマをより細かく分けている場合、それは必ずしも生産性の向上を意味するわけではありません）。</li>
  <li>レビュー段階でのコードの見直し回数</li>
  <li>QA段階でのコードの見直し回数</li>
  <li>更新されていない依存関係の数</li>
  <li>アプリケーション内の依存関係の総数</li>
  <li>単位時間あたりのバグチケットの数</li>
  <li>単位時間あたりの緊急チケットの数</li>
  <li>単位時間あたりの技術的なタスク（コードのリファクタリングなど）の数。依存関係の更新などのメンテナンスタスクは除外します。</li>
  <li>これらのチケットの全体の負荷に対する割合、特にビジネス側からのチケットに対して</li>
  <li>仕様書の段階にあるチケット（または/およびスクラムポイント）の数</li>
  <li>開発待機中のチケット（または/およびスクラムポイント）の数</li>
  <li>開発中のチケット（または/およびスクラムポイント）の数</li>
  <li>自動化テストによるコードのカバレッジ</li>
  <li>アプリケーションコードに対するテストコードの比率</li>
</ul>

<p>個人的には、これらの指標を現在自動的に追跡しているわけではありませんが、主観的にその進行状況を把握し、意思決定時に考慮しています。また、特定の選択肢を正当化するためにも使用しています。</p>

<p>これらの指標は、コードの品質が良いか悪いかを直接示すものではありませんが、その進化を追跡することで、品質が向上しているのか、低下しているのかを簡単に把握することができます。</p>

<h1 id="結論">結論</h1>

<p>良い開発品質は単に機能するコードを作成することにとどまらず、仕様の明確さ、コード構造、保守性、そして将来的な変更の予測を含む包括的なアプローチに基づいています。このアプローチは初期投資が多くなりますが、誤りを減らし、長期的な生産性を向上させ、チーム内での協力を促進します。</p>

<p>厳密な仕様書の作成、慎重な開発、そして関連する指標の監視を組み合わせることで、プロジェクトの品質を段階的に向上させることができます。目標は絶対的な完璧さを追求することではなく（それは幻想にすぎません）、継続的な調整を可能にする反復的で測定可能なアプローチを採用することです。最終的に、良い品質のコードは開発者だけでなく、ユーザーや企業全体にも利益をもたらします。</p>]]></content><author><name></name></author><category term="Bonnes-Pratiques" /><category term="Ruby" /><category term="Rails" /><category term="Architecture" /><category term="Développement" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">Fail Fast: 本番環境のバグを素早く修正するために素早く失敗する</title><link href="/bonnes-pratiques/ruby/rails/architecture/2025/03/24/fail-fast-echouer-rapidement-pour-corriger-les-bugs.html" rel="alternate" type="text/html" title="Fail Fast: 本番環境のバグを素早く修正するために素早く失敗する" /><published>2025-03-24T07:00:00+00:00</published><updated>2025-03-24T07:00:00+00:00</updated><id>/bonnes-pratiques/ruby/rails/architecture/2025/03/24/fail-fast-echouer-rapidement-pour-corriger-les-bugs</id><content type="html" xml:base="/bonnes-pratiques/ruby/rails/architecture/2025/03/24/fail-fast-echouer-rapidement-pour-corriger-les-bugs.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>「Fail Fast（フェイルファスト）」戦略とは、アプリケーションの開発または実行サイクルの中でできるだけ早い段階でエラーを検出し、即座に修正することで、より深刻な問題を未然に防ぐことを目的としています。これにより、コードの安定性と保守性が向上します。</p>

<p>Web アプリケーションにおいて、ユーザーが感じるサービスの品質は、エラーを検出し迅速に対処する能力に大きく依存します。</p>

<p>この記事では、監視ツールを使用してエラーを特定し、迅速に修正する方法を紹介します。その後、より複雑なエラーを処理するための戦略について説明します。</p>

<h1 id="監視ツール">監視ツール</h1>

<p>Rails アプリケーションでは、エラーはログに記録されますが、誰もログを確認しない場合、ユーザーが報告しない限りエラーは見過ごされる可能性があります。</p>

<p>そのため、Rollbar、AppSignal、Sentry などの専用の監視ツールを使用することが推奨されます。これらのツールを導入することで、エラーを直感的なインターフェース上で効率的に管理できます。新しいアプリケーションでは、こうしたツールの導入を最優先事項とすべきです。</p>

<p>このようにして、エラーは自動的に分類・集計され、重要なエラーに集中できるようになります。また、エラー発生時には即座に通知を受け取ることができるため、迅速に対応でき、ユーザーへの影響を最小限に抑えられます。</p>

<h1 id="修正の優先順位付け">修正の優先順位付け</h1>

<p>プロジェクトの初期段階から監視ツールを導入していれば、発生するエラーの数は少なく、都度修正することが可能になります。</p>

<p>基本戦略はシンプルです。エラーが発生した際に通知を受け取り、エラー数が少なければ、作業を一時中断して即座に修正するのが最善です。</p>

<p>しかし、エラーの量が多くなると、優先順位を付ける必要があります。その際に考慮すべきポイントを以下に示します。</p>

<h2 id="作業を中断してエラー対応をすべきか">作業を中断してエラー対応をすべきか？</h2>

<p>エラーの数が多すぎると、頻繁な中断が発生し、他の修正や新機能の開発が遅れる可能性があります。その場合は、定期的にエラーをチェックし、通常のワークフローに修正を組み込むことで、影響を最小限に抑えるのが効果的です。</p>

<p>例えば、毎日一定の時間を割いて新しいエラーをリストアップし、タスク管理ツールに記録し、他の作業との優先順位を調整する方法が考えられます。</p>

<h2 id="エラーの緊急度はどの程度か">エラーの緊急度はどの程度か？</h2>

<p>エラーが収益や評判、ユーザー体験に与える影響を考慮します。回避策が存在するかどうかも重要なポイントです。これらの情報を基に、エラー修正の優先順位を決定します。</p>

<h2 id="エラー修正に十分な時間を割いているか">エラー修正に十分な時間を割いているか？</h2>

<p>エラーの発生数を定量的に追跡し、増加傾向にあるか、減少しているかを分析します。その結果に基づいて、修正に割く時間を調整できます。</p>

<h1 id="fail-fast-戦略による複雑なエラーの解決">Fail Fast 戦略による複雑なエラーの解決</h1>

<p>ほとんどのエラーは、修正が容易です。開発中の単純な見落としであることが多く、監視ツールの情報を見れば迅速に対応できます。</p>

<p>しかし、一部のエラーは解釈が難しいものがあります。例えば、変数やオブジェクトの属性が <code class="language-plaintext highlighter-rouge">nil</code> になってしまい、コードが想定する値がない場合などです。</p>

<p>このような問題は、アプリケーション内にバリデーションが存在していても発生することがあります。原因としては以下のようなケースが考えられます。</p>

<ul>
  <li>データがバリデーションを通さずに追加・変更された（意図的または意図せず）</li>
  <li>バリデーションが追加される前に、不正なデータがすでに存在していた</li>
</ul>

<p>結果として、無効なデータがアプリケーションのさまざまな箇所でバグを引き起こし、診断が難しくなります。</p>

<p>例えば、ユーザーを削除する際にデータベースの制約が設定されていなかった場合、そのユーザーの注文データが孤立してしまう可能性があります。その状態で注文データから関連するユーザーを取得しようとすると、<code class="language-plaintext highlighter-rouge">undefined method `name' for nil</code> という典型的なエラーが発生します。この問題を防ぐために、外部キー制約を設定することで、関連する注文データがあるユーザーを削除できないようにするべきです。これにより、不整合を防ぎ、エラーが発生した瞬間に問題を明確にできます。</p>

<p>このようなケースでは、データベース内の不正なデータを修正した後、再発を防ぐために制約を追加することを推奨します。</p>

<p>具体的には、以下のような手法が考えられます。</p>

<ul>
  <li>整合性制約 (<code class="language-plaintext highlighter-rouge">NOT NULL</code>, <code class="language-plaintext highlighter-rouge">FOREIGN KEY</code>, <code class="language-plaintext highlighter-rouge">UNIQUE</code>)</li>
  <li>トリガー（特定の条件下でデータベースが自動で処理を実行）</li>
</ul>

<p>こうすることで、同じ問題が発生した場合、監視ツールが即座に関連するコードを特定できます。</p>

<p>このような制約を追加すると、正当な懸念が生じる可能性があります。ここでは、それに対処する方法を説明します。</p>

<h1 id="制約のある環境で">制約のある環境で</h1>

<p>このような解決策を提案すると、しばしば反発を受けます。それには正当な理由があります。</p>

<ul>
  <li>制約がプロセスの正常な動作を妨げ、送信されたデータが失われる可能性がある。</li>
  <li>問題を修正するどころか、新たなエラーを引き起こす可能性がある。</li>
</ul>

<p>これらの懸念はもっともですが、代替案の方が問題です。それは、エラーを許容することです。時間が経つにつれて、不正なデータが蓄積し、アプリケーションが不安定になります。</p>

<p>さらに、この状況は一時的なものです。確かに、ユーザーがエラーに遭遇することはありますが、そのおかげで迅速に恒久的な修正を施すことができます。データが適切に検証されていれば、同じエラーが再び発生することはなくなります。</p>

<p>プロセスが重要なものである場合、問題が再現されたらすぐに制約を解除することで、影響を最小限に抑えることができます。しかし、場合によっては、これすら許容できないこともあります。そのようなケースでは、プロセスを継続しつつ、エラーを記録するという選択肢もあります。ただし、このアプローチはエラーの発生源がデータベースである場合、より複雑になります。</p>

<p>トリガーを変更して、データを特定のテーブルに記録することができます。PostgreSQL では、<code class="language-plaintext highlighter-rouge">CREATE RULE</code> を <code class="language-plaintext highlighter-rouge">NOTIFY</code> と組み合わせて使用することも可能です。これにより、監視ツールにエラーを送信する処理を追加できます。</p>

<h1 id="この戦略のメリット">この戦略のメリット</h1>

<p>このアプローチは、「Fail Fast」戦略のメリットを明確に示しています。それは、異常な状態が検出された時点で、システムを即座に停止させることです。</p>

<p>ここではデータベースの制約を例に説明しましたが、この戦略は他のコンテキストにも適用できます。例えば、メソッドの実行開始時に事前条件をチェックすることなどが挙げられます。</p>

<p>早い段階で失敗させることで、不正なデータがコード全体に広がるのを防ぎ、不必要な防御的ロジックを排除し、保守性を向上させることができます。防御的なコードを追加することは良い戦略とは言えません。なぜなら、どこでチェックが必要なのかを完全に把握することは難しく、さらに、将来の変更でチェックが抜け落ちる可能性もあるからです。</p>

<h1 id="結論">結論</h1>

<p>バグが少なくなれば、それを修正するための時間が減り、その分アプリケーションの改善や進化に時間を割くことができます。このアプローチにより、保守が効率的になり、新機能の実装も容易になります。</p>

<p>直感に反するように思えるかもしれませんが、「Fail Fast」戦略はバグを減らし、アプリケーションの保守を簡単にするための優れたベストプラクティスです。</p>

<p>エラーが少なくなれば、それを修正するための時間も短縮され、その分のリソースをプロダクトの改善や拡張に充てることができます。この考え方を取り入れることで、保守が効率化され、コードの堅牢性が向上し、新機能の実装もよりスムーズに行えるようになります。</p>]]></content><author><name></name></author><category term="Bonnes-Pratiques" /><category term="Ruby" /><category term="Rails" /><category term="Architecture" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">Webアプリケーションのコード品質の改善</title><link href="/ruby/rails/architecture/2025/03/10/am%C3%A9liorer-la-qualit%C3%A9-de-vos-applications-web.html" rel="alternate" type="text/html" title="Webアプリケーションのコード品質の改善" /><published>2025-03-10T07:00:00+00:00</published><updated>2025-03-10T07:00:00+00:00</updated><id>/ruby/rails/architecture/2025/03/10/am%C3%A9liorer-la-qualit%C3%A9-de-vos-applications-web</id><content type="html" xml:base="/ruby/rails/architecture/2025/03/10/am%C3%A9liorer-la-qualit%C3%A9-de-vos-applications-web.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>私のウェブ開発者としてのキャリアを通じて、多くの異なるWebアプリケーションに取り組んできました。その中で、チームの組織が生産されるコードの品質にどのように影響するか、またそれがアプリケーションの安定性にどのように影響するかを観察することができました。</p>

<h1 id="人的要因の重要性">人的要因の重要性</h1>

<p>経験豊富な開発者で構成されたチームが直面する問題は、ジュニアの開発者で構成されたチームの直面する問題とは異なります。</p>

<p>初心者は、ベストプラクティスを無視した構造化されていないコードを生産しがちです。最も適切なツールについての知識が不足しているため、適切でないツールを使用することが多いです。また、経験不足のため、不完全な解決策を好む傾向があります。</p>

<p>経験を積むことで、開発者は自信を得て、時には不必要に複雑な解決策を開発することがあります。たとえば、あまりにも多くの抽象化層を使用したり、適切でないデザインパターンを使ったりする場合です。</p>

<p>最終的に、最も経験豊富な開発者は、時には組織的な問題を引き起こすことがあります。彼らは蓄積された経験によりさまざまな問題を解決するための高度なスキルを持っていますが、これが技術的な解決策を選ぶ際に対立を引き起こすことがあります。</p>

<p>これらの問題はすべて、アプリケーションのコード品質に影響を与える可能性があります。</p>

<h1 id="コードの構造はアプリケーションの品質に影響を与える">コードの構造はアプリケーションの品質に影響を与える</h1>

<p>アプリケーションでは、「コードの構造」という概念は非常に曖昧であり、いくつかの異なる概念を表すことができます。以下はその例です：</p>

<ul>
  <li>ファイルの組織（名前やファイルシステム内での位置）</li>
  <li>ファイル内でコードがどのように整理されているか（コードオブジェクトの順序、長さ）</li>
  <li>コードオブジェクトがどのように相互作用またはカプセル化されているか…</li>
</ul>

<p>このリストは網羅的ではありません。本記事ではファイルの組織に焦点を当てますが、問題とその結果は他のコード組織の側面にも同様に適用されます。実際、これらの各側面はアプリケーションの構造に影響を与えます。</p>

<h2 id="ファイルの組織">ファイルの組織</h2>

<p>ファイルはコードを表し、Rubyでは通常、モジュールやクラスが含まれます。Railsのようなフレームワークを使用すると、基本的なファイル階層が提供されるため、これを簡素化するのに役立ちます。たとえば、設定用の<code class="language-plaintext highlighter-rouge">config</code>フォルダ、MVCロジック用の<code class="language-plaintext highlighter-rouge">models</code>、<code class="language-plaintext highlighter-rouge">views</code>、<code class="language-plaintext highlighter-rouge">controllers</code>フォルダなどです。</p>

<p>シンプルなアプリケーションの場合、この階層はファイルを整理するには十分です。しかし、アプリケーションの複雑さが増すと、ファイルも増え、それらはますます大きくなります。</p>

<p>Railsは「concerns」（オブジェクトの側面を表すモジュール）という概念を導入して、機能をモジュールに分割し、それを組み合わせて大きなエンティティを作成します。簡単に言えば、ファイルのコードをいくつかのファイルに分割するわけです。</p>

<p>ここで問題が始まることがよくあります。コードをどのように分割するかを決定する必要があるからです。どのメソッドやマクロをどのファイルに入れるか、どの論理に基づいて分けるかを決める必要があります。また、新しいファイルの名前をどう付けるかも重要です。さらに、複数の<code class="language-plaintext highlighter-rouge">concerns</code>モジュールを積み重ねる代わりに、コードのアーキテクチャを変更して新しい概念やクラスを導入する方が適切ではないかと考えるべきです。</p>

<p>そして、これらの質問には理想的な唯一の答えはありません。どの選択肢にも長所と短所があります。一部の選択肢は重要な影響を与える可能性があり、慎重に検討する必要がありますが、他の選択肢はあまり重要でなく、任意の決定でも十分満足できる場合があります。しかし、どの決定が重要になるかを予測するのは難しいこともあります。</p>

<p>いくつかの構造的な問題とその結果について分析してみましょう。</p>

<h2 id="一部の構造的な問題">一部の構造的な問題</h2>

<p>最も明らかな問題は、ファイル、クラス、モジュールの名前が不適切であることです。</p>

<p>命名規則に従わないこと（プロジェクトやコミュニティ内で普及している規則と異なる規則を使用すること）。たとえば、Rubyでは、クラスやモジュールの名前はCamelCaseを使用します。この規則に従うことは、Rubyコミュニティが共通して使っているため、コードの読み書きやナビゲートが非常に楽になります。この規則に従わないことは重大な問題ではありませんが、コードベースで作業する際には面倒になります。また、コード品質は何千行ものコードが含まれているアプリケーションでは決して理想的とは言えません。これは簡単に避けられる問題であるにもかかわらず、他の問題を引き起こすことになります。</p>

<p>時には、ファイル、オブジェクト、メソッド、変数の名前を急いで選んでしまうことがあります。これは非常に一般的な問題です。開発中、私たちはほとんどの時間をオブジェクトを作成しているため、それらに名前を付けています。オブジェクトに名前を付けて次の部分に進むのは誘惑的ですが、名前の選択が不適切だと深刻な影響を与えることがあります。コードが読みにくく、理解しにくくなります。名前を誤解すると、大きなバグが発生し、見逃しやすくなります。たとえば、名前が示唆する通りに動作しないオブジェクトは、誤って使用されることがあり、そのバグは必ずしも簡単に見つかるわけではありません。</p>

<p>オブジェクトをいくつかのパーツに分割する場合、問題がすぐに悪化します：</p>

<p>簡単さや怠慢のために、技術的な概念をビジネスの概念として使用することがあります。たとえば、アソシエーションの定義を1つのファイルに、バリデーションを別のファイルに分けることです。コールバックやフィルタなどをすべて抽出することです。一般的には、ビジネスに関連する側面を特定し、そのすべてを1つのファイルにまとめる方が適切です（たとえば、請求用のモジュール、プロセスマネジメント用、住所用、顧客データ用など）。このタイプの問題は、読みにくくなるだけでなく、コードの変更を複雑にします。変更が複数のファイルにまたがることになるからです。</p>

<p>また、不要に抽象化や中間オブジェクトを導入してしまうこともあります。これにより、間接的な処理が発生し、コードの流れを追うために複数のファイルをナビゲートし、迷子になる可能性があります。読みやすさが複雑になり、場合によっては、対応するコードを変更することも難しくなります。</p>

<p>構造的な問題は時に深刻です。たとえば、複雑な技術的ロジックを使用してコードの利用が難しくなることがあります。たとえば、<code class="language-plaintext highlighter-rouge">models</code>フォルダに加えて<code class="language-plaintext highlighter-rouge">services</code>や<code class="language-plaintext highlighter-rouge">operations</code>フォルダを作成し、ビジネスロジックをその両方に分けることです。このようなフォルダを作成すること自体は問題ではありませんが、コードベース全体が一貫していなければなりません。そうでないと、コードは読みやすさや変更のしやすさを損なうことになります。悪い習慣がコードに深く根付いている場合、それを整理するのは非常に時間がかかり、難しい作業です。</p>

<p>同様に、ビジネスロジックをヘルパー、ビュー、またはコントローラーに配置することも同じ問題を引き起こします。概念に関するすべてのビジネスロジックを1つの場所にグループ化することは、アプリケーションの保守性を確保するために非常に重要です。</p>

<h1 id="ベストプラクティスを守る重要性">ベストプラクティスを守る重要性</h1>

<p>構造的な問題がコード品質に影響を与え、バグを引き起こすことがあることはわかりました。日常的にベストプラクティスを守ることも重要です。</p>

<h2 id="linterの使用と遵守">Linterの使用と遵守</h2>

<p>ほとんどのベストプラクティスは、Linter（コード解析ツール）を使用することで簡単に遵守できます。</p>

<p>Rubyの場合、RuboCopが推奨されます。個人的には、すべてのポリシーを有効にし、可能な限りデフォルト設定を使用しています。</p>

<p>最初は、特定の制約（メソッドを10行以内にする、行の長さを制限する、モジュールの最大行数など）を守るのが面倒で無意味に思えるかもしれません。これが原因で、開発者は以下のような理由でルールを守らないことを正当化しがちです：</p>

<ul>
  <li>コードは十分に読みやすい</li>
  <li>他の誰にも迷惑をかけない</li>
  <li>この場合にはバグがない</li>
  <li>セキュリティ上の問題はない</li>
  <li>このルールを守らないことで大きなメリットが得られる</li>
  <li>など</li>
</ul>

<p>私の意見では、ルールを一貫して適用することの方が重要であることが多いです。確かに、ルールを守らなくても問題がない場合もありますが、大抵の場合、修正後のコードの方が良くなります。場合によっては、確かにコードが少し悪くなることもあります（たとえば、読みやすさが少し低下するなど）。しかし、この場合でもほとんどのケースではコードはわずかに悪くなりますが、以下の利点によってそのデメリットは補われます：</p>

<ul>
  <li>ルールを無視することで、他の開発者がそれを無視したり、Linterのルール全体を無視するようになるかもしれません。これにより、コードが一貫性を欠き、最悪の場合、バグや可読性の問題が発生することになります。これを避けることは確かな利点です。</li>
  <li>コードは一般的に一貫しており、したがって読みやすくなります。たとえこれが時々コードが若干読みづらくなることを意味していても、それを超えるメリットがあります。</li>
</ul>

<p>そのため、Linterを使用してそれに従うことは、コード品質に大いに貢献します。</p>

<p>もちろん、特定のルールが十分な利益を提供しないと感じる場合や、個人的な好みによりLinterの設定を変更したい場合もあります。</p>

<h2 id="その他のベストプラクティス">その他のベストプラクティス</h2>

<p>その他のベストプラクティスも重要です。経験豊富な開発者は、初心者よりもそれらをより多く知り、習得しています。</p>

<p>そのため、コードのレビューを経験豊富な開発者に依頼することは、良いコード品質を確保するために重要です。</p>

<p>私にとって最も重要なベストプラクティスは以下の通りです：</p>

<ul>
  <li>SRP - 単一責任の原則（Single Responsibility Principle）：各コードオブジェクトは、一度に一つの側面に集中すべきです。</li>
  <li>KISS - Keep It Simple and Stupid：コードはシンプルで愚直に保つべきです。言い換えれば、複雑な解決策よりもシンプルで直接的な解決策が好ましいということです。</li>
  <li>YAGNI - You Aren’t Gonna Need It：あなたはそれを必要としないでしょう。これはKISSの対義語です。もし今必要でない機能や抽象化（例えば、発生しにくいエラーの処理）があるなら、それは実際に必要になるまで開発する意味はありません。</li>
</ul>

<p>これらのベストプラクティスは時々互いに矛盾することがあります。その場合は、どれを優先するかを選ぶ必要があります。</p>

<p>ベストプラクティスを守ることはコード品質に大きな影響を与えます：</p>

<ul>
  <li>ここでも、コードの読みやすさが向上します。</li>
  <li>生産されるコードの量も最小限に抑えられるため、生産性の向上がもたらされます。</li>
  <li>コードの進化が容易になり、コードに適切なレベルの複雑さが与えられます。</li>
  <li>コードのシンプルさ、密度、分岐の制限により、メンテナンスが容易になります。</li>
  <li>同じ理由で、バグの数も制限されます。</li>
</ul>

<h1 id="適切なツールの選択">適切なツールの選択</h1>

<p>コード品質にとって、良いツールの選択も重要です。選択は、アプリケーションの特定のコンテキストに基づいて行うべきです。あるアプリケーションに適したツールが、別のアプリケーションには適さないことがあります。</p>

<p>ツールを選ぶ際のいくつかの重要な基準は次の通りです：</p>

<ul>
  <li>チームの組織と全体的なレベル：あるツールは特定の組織には適しているかもしれませんが、別の組織では逆効果になることもあります。例えば、経験の少ないチームに対しては、シンプルなツール（性能が劣る場合でも）を選ぶ方が、直感的でない複雑なツールよりも適しています。</li>
  <li>メンテナンスと人気：完璧に適したツールがあっても、それがあまりにマイナーでメンテナンスが不十分な場合、むしろ良くメンテナンスされていて人気のあるツールを選んだ方が良いことが多いです。当然、非常に適したが人気がないツールを選んで、自分で修正したり適応させたりすることは十分可能です。</li>
  <li>ライセンス：しばしば見過ごされがちですが、ツールのライセンスを確認することは重要な基準です。特に、アプリケーションが人気を集めると、法的な問題を避けるためにライセンスをチェックする必要があります。</li>
</ul>

<h1 id="多くのショートカットを取らない">多くのショートカットを取らない</h1>

<p>複雑な機能を開発する際に一般的な誤りは、KISS原則を過度に適用することです。</p>

<p>コードをシンプルに保つことは確かに重要ですが、機能がどのように使われるかを予測することも同様に重要です。</p>

<p>実際には、開発者は仕様書に基づいて機能を実装しなければなりません。</p>

<p>私が働いた企業では「アジャイル」手法を使用しています。実際には、アイデアを仕様として指定し、それを提供するまでの時間をできるだけ短縮したいという意味です。実際のニーズが表現されたニーズに完全に一致しない場合でも、定期的に見直すことを意味します。</p>

<p>その結果、仕様書を慎重に書いたとしても、しばしば多くのギャップが生じます。個人的には、主なニーズに仕様書の作成努力を集中することがよくあります。これにより、詳細な技術仕様や二次的なユースケースが犠牲になることがよくあります。これらの側面は、開発の他の部分、つまり機能を実装する開発者、レビュー担当の開発者、品質保証チームに委ねられます。</p>

<p>例えば、開発者はエラーケースの処理を見逃すことがあるか、または代替ユースケースを予測できず、完全にニーズに対応しない機能を提供することがあります。</p>

<p>もちろん、詳細な技術仕様を追加すれば、これらの欠点を制限することは可能ですが、コード、ニーズ、使用法、書き込みを分析するために必要な時間が大幅に増加します。ドキュメント作成にかかる時間が増え、仕様でニーズを表現する能力が低下し、結果として開発能力が減少します。そして、すべての側面が考慮される保証もありません。</p>

<p>これを避けるためには、開発者が機能がどのように使われるかというコンテキストを理解することが非常に重要です。アプリケーションの動作に関する正確な知識を持つことで、技術的なニーズを明確にすることができます。例えば、コードに分岐が欠けているかどうかを簡単に見抜くことができ、分岐を作成すべきかどうかを問い直すことができます。また、仕様でエラーケースが処理されていないことに気付くこともできます。</p>

<p>仕様書を文字通りに適用することを避け、挑戦する姿勢を持つことで、バグを防ぎ、アプリケーションの品質向上に貢献できます。さらに、これにより往復作業や開発ステージを避け、最終的にはチームの生産性が向上します。</p>

<h1 id="過剰に設計されたコード">過剰に設計されたコード</h1>

<p>これは前述のケースの対極です。複雑な機能を開発する際に、開発者が過剰に予測して不必要な抽象化を導入することがあります。これらの抽象化により、コードの読みやすさと保守性が低下します。</p>

<p>このようなコードは、レビュー時に検出するのが難しいことがよくあります。</p>

<p>しかし、いくつかのアプローチで対処することができます。例えば、次のような方法です：</p>

<p>レビュー時に、典型的でないアプローチを取っているコードを簡単に識別できます。そのアプローチが複雑である場合、それに挑戦することが重要です。</p>

<p>そのために、白紙の状態から始めて、機能を開発するために使用されるべきアーキテクチャを想像してみてください。</p>

<p>想像された解決策は簡素である可能性が高いです。なぜなら、レビュー担当者はすべての詳細を把握していないからです。その後、選ばれたアーキテクチャと比較します。もし選ばれたアーキテクチャが、レビューされたコードよりも大幅に簡素であれば、追加の複雑さが本当に必要かどうかを開発者と議論することができます。</p>

<p>この種の問題は、アプリケーションの保守や進化に非常に大きな影響を与えます。数ヶ月後に戻って対処するのは非常に難しいことが多いです。したがって、これらを早期に検出し、排除することが極めて重要です。</p>

<h1 id="開発者間の対立">開発者間の対立</h1>

<p>経験を積むと、開発者は習慣を形成します。しかし、開発にはしばしば複数の等価な解決策があります。</p>

<p>そのため、経験豊富な開発者が自分にとってうまくいった解決策を実装したいと考えることはよくあります。</p>

<p>場合によっては、これは開発者が入社する前に行われた選択を見直すことを意味します。時には、新機能に関する問題です。</p>

<p>ほとんどの場合、これは開発者間の議論につながり、時間を消費することがあり、時にはチームの雰囲気に影響を与えることもあります。</p>

<p>これらの議論を軽視しないことが重要です。技術的な選択肢が必ずしも非常に重要でない場合でも、人間的な影響はかなり大きくなる可能性があります。</p>

<p>開発者が理解することが重要なのは、自分にとって劣って見える技術的選択が必ずしも問題でなく、重大な影響を与えることはないということです。</p>

<p>一方で、これらの代替案は時には実際に本当の利益をもたらすことがあり、その潜在的な利益を見過ごすべきではありません。もちろん、それを実装するために必要な労力と照らし合わせて考慮すべきです。もし実装にかかる労力が期待される利益を上回る場合、残念ながら、既存の解決策が劣っていても、それを維持する方がよい場合があります。</p>

<p>しかし、この選択は最終的に機能が再度書き直されたり、アプリケーションやチームが進化したりする時に再検討できます。</p>

<p>一般的に、この種の対立はコード品質には直接的な影響を与えません。しかし、もし対立が解決されなければ、アプリケーション内に複数の競合する解決策が存在することになり、これは明らかに保守上の問題を引き起こします。</p>

<h1 id="結論">結論</h1>

<p>簡潔に言うと、コード品質とアプリケーションの安定性は、チームの組織、ベストプラクティスの遵守、技術的選択肢の管理によって直接的に影響を受ける問題です。ファイルの整理やアーキテクチャの決定に関する構造的な問題は、可読性や保守性、最終的にはアプリケーションの品質に重要な影響を与えることがあります。ベストプラクティスを一貫して遵守し、適切なツールを使用し、建設的な議論の文化を作り上げることが、あなたのWebアプリケーションの長期的な成功を確保するために役立ちます。</p>]]></content><author><name></name></author><category term="Ruby" /><category term="Rails" /><category term="Architecture" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">ActiveRecord vs Repository: それぞれの違いを理解する</title><link href="/ruby/rails/architecture/2025/03/02/le-pattern-active-record-n-est-pas-repository.html" rel="alternate" type="text/html" title="ActiveRecord vs Repository: それぞれの違いを理解する" /><published>2025-03-02T07:00:00+00:00</published><updated>2025-03-02T07:00:00+00:00</updated><id>/ruby/rails/architecture/2025/03/02/le-pattern-active-record-n-est-pas-repository</id><content type="html" xml:base="/ruby/rails/architecture/2025/03/02/le-pattern-active-record-n-est-pas-repository.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>今回はよく知られたケーススタディについて話します。すべてのRails開発者は、データベース操作を行った後にメールを送信する必要に直面します。典型的には、ユーザーがサービスに登録した後に歓迎メールを送ることです。しかし、この単純なタスクは、特にActiveRecordのコールバックやデータベーストランザクション、キューが関わると、すぐに複雑になりがちです…</p>

<p>この問題は、Ruby on RailsにおけるActiveRecordパターンとRepositoryパターンの間で生じる混乱を説明するための前提です。</p>

<h1 id="シナリオ">シナリオ</h1>

<p>状況は非常に普通です：ユーザー登録はデータベースの<code class="language-plaintext highlighter-rouge">users</code>テーブルに行を作成することに対応します。ActiveRecordの用語を使うと、単純に「新しいユーザーを作成する」と言います。</p>

<p>そして、これが完璧です。私たちの開発者はあまり経験がないかもしれませんが、しっかり学んでおり、ActiveRecordには<code class="language-plaintext highlighter-rouge">after_create</code>というコールバックがあり、ユーザーが作成された後にメールを送信したいということを理解しています。</p>

<p>また、私たちのジュニア開発者は、メール送信はキューを使って行うべきだと学んでおり、SidekiqやGood Job、Solid Queueを使っています。</p>

<p>あっという間に、5分で、開発者はユーザー作成後にメールを送信する設定をしました…それは動作しているように見えますが、問題があります…毎回うまくいくわけではなく、とても不安定です。時々はメールが送信されますが、時々は送信されません。</p>

<h1 id="問題の分析">問題の分析</h1>

<p>何がうまくいかないのかを理解するために、ジュニア開発者はここでトランザクションがどのように関わっているのかを理解する必要があります。</p>

<p>Railsはデータベース操作（<code class="language-plaintext highlighter-rouge">save</code>）にトランザクションを使用します。つまり、ユーザー作成中にエラーが発生すると、トランザクション全体（<code class="language-plaintext highlighter-rouge">users</code>テーブルへの挿入やその他の関連するアクション）はキャンセルされ、データベース内の何も変更されません。すべてが順調に進むと、Railsはトランザクションをコミットし、すべてのテーブルが同時に更新されます。</p>

<p>そして、ここで問題が発生します。私たちのアプリでは<code class="language-plaintext highlighter-rouge">after_create</code>コールバックを使用してメールをキューに追加しますが、このコールバックはトランザクションが終了する前にトリガーされます。メールがキューに追加された時点では、トランザクションはまだ完了していません。メールジョブがトリガーされるとき、トランザクションは必ずしもコミットされておらず、ユーザーはまだデータベース内で完全に作成されていないため、ジョブの実行中にユーザーがデータベースに見つからないというエラーが発生します。</p>

<h1 id="シニアからの誤ったアドバイス">シニアからの誤ったアドバイス</h1>

<p>もちろん、ジュニア開発者は何がうまくいかないのか理解できず、シニアに相談します。シニアはこう言います。「君は不運だ、コールバックを使っているのは悪だ、永遠に呪われるべきだ！」</p>

<p>ジュニアはさらに混乱します – もしコールバックを使ってはいけないなら、なぜRailsにコールバックがあるのでしょうか？</p>

<p>「君は責任分担を理解していない。ActiveRecordはデータベース用で、メール送信に使ってはいけない。メール送信にはサービスを使うべきだ。しかも、ActiveRecordを使ってサービスを呼ばないで、コントローラを使うべきだ。しかし、コントローラが汚れてしまうから、dry-transaction<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>を使うんだ。」</p>

<p>そして、ジュニア開発者はメールを送るために1週間を費やすことになります。</p>

<p>シニアは悪意があったわけではありませんが、これでは実際の問題を解決せず、状況を不必要に複雑にしています。</p>

<h1 id="誤った点を整理しましょう">誤った点を整理しましょう</h1>

<p>このケースでは、シニア開発者は間違っています。dryエコシステムや責任分担、データベースコードと外部サービス関連のコードの分離の利点を称賛することは間違っていませんが、それをジュニアに強制するのは間違いです。</p>

<p>シニアの間違いは、誤解にあります。ジュニアの問題はコールバックの使用に関するものではありません。実際、もしメールがジョブ内で送信されなければ、コールバックは問題にならなかったでしょう。ジョブも問題ではなく、もしジョブがトランザクションの後にトリガーされていれば、すべてうまくいったはずです。</p>

<p>ここでジュニアがやるべきことは、<code class="language-plaintext highlighter-rouge">after_create</code>を<code class="language-plaintext highlighter-rouge">after_create_commit</code>に置き換えることです。この場合、メールはトランザクションが完了した後に送信され、問題が解決します。これにより、ジュニアはコールバックの内部動作やその順序、データベーストランザクションとの相互作用をより深く理解することができるでしょう。</p>

<p>シニアは、このアドバイスを最初に伝えるべきでした。もしアーキテクチャの議論をしたいのであれば、誤った、あるいは最悪の場合は詐欺的な論点を使って自分の方法を強制し、ソフトウェアアーキテクチャの決定に安心を求める代わりに、ジュニアを助けるべきでした。こうすることで、ジュニアを助けることなく、問題を回避することになります。</p>

<p>ただし、シニアの解決策も機能しますが、それを実装するにはコストがかかります。</p>

<h1 id="activerecordはrepositoryパターンではない">ActiveRecordはRepositoryパターンではない</h1>

<p>シニアが犯したもう一つの誤解は、ActiveRecordがRepositoryパターンではないということです。</p>

<p>ActiveRecordの定義に戻ると、ActiveRecordクラスはデータとビジネスロジックの両方をカプセル化することを目的としています。さて、メール送信はビジネスロジックの一部であり、このパターンではActiveRecordによってトリガーされることが完全に正当です。</p>

<p>Repositoryパターンでは、これは当てはまりません。Repositoryクラスの責任は、データベースとの通信のみであり、ビジネスロジックを含んではいけません。Railsでは、ActiveRecordをRepositoryパターンと一緒に使用することも可能ですが、これはActiveRecordの多くの機能（おそらくコールバックも含む）を放棄することを意味します。</p>

<p>しかし、これはアーキテクチャの選択です。一つのやり方しかないわけではありません。各選択肢には、それぞれの結果、利点、欠点があります。そして、もちろん、それは個人の好みにも関わる問題です。</p>

<p>私にとって、ActiveRecordの主な利点はコードの可読性であり、その魔法のような部分は実際には隠された複雑さです（例えば、犬に吠えさせるために<code class="language-plaintext highlighter-rouge">dog.bark!</code>と書く代わりに、<code class="language-plaintext highlighter-rouge">DogBarker.new(AnimalFactory.create(:dog, DogAttributeValidator.validate(dog_attributes)).call</code>のように書かないということです）。外部サービスを呼び出す場合でも、実装の詳細は隠されています）。</p>

<p>しかし、この利点には代償があります。この代償を払う覚悟がない人は、別のアーキテクチャを選択することができます。しかし、他の全員に自分の決定を強制することなく、その決定を自分で確認すべきです。</p>

<p>ジュニアが自分のアーキテクチャの選択をし、賛否を天秤にかけて判断できるようにしましょう。</p>

<h1 id="結論">結論</h1>

<p>すべてのアーキテクチャ選択には欠点があります。ActiveRecordにも欠点はありますが、コールバックは強力なツールであり、ジュニア開発者がそれを使用するのを躊躇させるのではなく、どのように機能し、正しく使う方法を理解し、使いこなせるように促すことは重要だと思います。</p>

<p>議論の中で、論拠を使い、事実に基づき、実用的で、開かれた態度を保ち、礼儀正しく接しましょう。そして、私がここでやったようなストローマン論法を使わないようにしましょう…</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>dry-transactionツールは、ビジネスステップを異なるオブジェクトにカプセル化するアプローチで、責任を分離することによりコードの構造を改善します。ただし、一貫性のために、アプローチに合わせてアプリケーション全体のコードを変換する必要があり、開発チームのトレーニングも必要となります。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="Ruby" /><category term="Rails" /><category term="Architecture" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">PostgreSQLのインストール方法: Homebrew対Docker対Postgres.app</title><link href="/postgresql/homebrew/docker/2024/11/26/installer-postgresql-homebrew-vs-docker-vs-postgres-app.html" rel="alternate" type="text/html" title="PostgreSQLのインストール方法: Homebrew対Docker対Postgres.app" /><published>2024-11-26T06:00:00+00:00</published><updated>2024-11-26T06:00:00+00:00</updated><id>/postgresql/homebrew/docker/2024/11/26/installer-postgresql-homebrew-vs-docker-vs-postgres-app</id><content type="html" xml:base="/postgresql/homebrew/docker/2024/11/26/installer-postgresql-homebrew-vs-docker-vs-postgres-app.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>PostgreSQLのインストールは、いくつかの方法で行うことができます。本記事では、さまざまなインストール方法の利点と欠点を探り、どの方法が特定のニーズに最適かを判断します。</p>

<p>本番環境用のインストールと開発用のインストールの違いを理解することは重要です。なぜなら、それぞれのコンテキストには独自の課題と優先事項があるからです。</p>

<p>まずは本番環境に関する一般的な考慮事項から始め、その後、開発環境におけるさまざまなインストール方法について深く掘り下げていきます。</p>

<h1 id="本番環境でのpostgresqlのインストール">本番環境でのPostgreSQLのインストール</h1>

<p>本番環境でのPostgreSQLのインストール方法を選択することは、アプリケーションのパフォーマンス、セキュリティ、堅牢性を確保するために不可欠です。この概要はすべての可能性を網羅しているわけではありませんが、選択肢を明確にし、特定のニーズに最も適したオプションに向けたガイドを提供することを目的としています。特に、マネージドデータベースを使用することと、独自の専用サーバーにインストールすることの違いについて説明します。</p>

<h2 id="マネージドデータベースサービスの使用">マネージドデータベースサービスの使用</h2>

<p>多くのプロジェクト、特に始まったばかりのプロジェクトにとって、マネージドデータベースインスタンスを選択することが最も明白な選択であることが多いです。このアプローチの主な利点は次のとおりです：</p>

<ul>
  <li><strong>デプロイの容易さ:</strong> 簡単にセットアップでき、通常ワンクリックで安全で最適化されています。手動や技術的なインストール手順は不要です。</li>
  <li><strong>即時の可用性:</strong> データベースはたいてい数十秒後に利用可能です。</li>
  <li><strong>メンテナンスの容易化:</strong> 更新とメンテナンスがプロバイダーによって管理されます。</li>
  <li><strong>簡略化された統合:</strong> 接続URLをアプリケーションに追加するだけで済みます。</li>
  <li><strong>自動バックアップ:</strong> このサービスも一般的にプロバイダーが管理しています。</li>
  <li><strong>高度な機能:</strong> 冗長性のようなオプションへのアクセス。</li>
  <li><strong>時間の節約:</strong> 特にプロジェクトの最初に、開発に集中することができます。</li>
</ul>

<p>しかし、いくつかの欠点があります：</p>

<ul>
  <li><strong>コストの増加:</strong> ニーズが増えるにつれて（実際には：データベースをより大きなインスタンスにアップグレードするとき）、コストが急増することがあります。</li>
  <li><strong>移行の複雑さ:</strong> データベースが大きくなった場合、他のプロバイダーへの移行がより複雑で、より高価で、アプリケーションのダウンタイムが増加します。</li>
  <li><strong>制御の限定:</strong> サーバーへの直接制御ができず、すべてのオプションにアクセスできないかもしれません。</li>
  <li><strong>必要な知識:</strong> データベースの内部動作の詳細を理解し、データベース内のデータ量が増えるにつれて良好なパフォーマンスを維持するための知識が必要です。</li>
  <li><strong>プロバイダーへの依存:</strong> 問題が発生した場合、貴重な助けとなることもありますが、ブロックする要因にもなり得るプロバイダーへの依存。</li>
</ul>

<p>例えば、私たちの会社は最初にマネージドデータベースサービスを選択しました。しかし、あるインシデントの後、コントロールの欠如が、他のプロバイダーへの移行、同様にマネージドサービスへの移行を予想以上に複雑にすることに気づき、それにより内部で管理されたソリューションを検討することになりました。</p>

<p>結論として、このソリューションはシンプルなニーズに適しています。即時のニーズと予算を考慮してください。アプリケーションが進化するにつれて、コストとコントロールの欠如が別の選択肢を正当化するかどうか評価してください。</p>

<h2 id="専用サーバーへのインストール">専用サーバーへのインストール</h2>

<p>PostgreSQLを自分で管理するサーバーにインストールすることも、もう一つの有効なオプションです。これは、Dockerを使って行うことも、従来のインストールを行うこともできます。これは、利用者の技術の好みによります。考慮すべき点として以下のようなものがあります：</p>

<ul>
  <li><strong>Dockerによるメンテナンス:</strong> Dockerを使用することで、PostgreSQLのアップデートに加え、Dockerのアップデートも管理する必要がある追加のメンテナンス層が追加されます。</li>
  <li><strong>プリコンフィギュアされたイメージ:</strong> Dockerはすぐに使えるイメージを提供しており、手動のインストールと比べて初期設定を簡単にします。</li>
  <li><strong>使いやすさ:</strong> Dockerに不慣れな人にとっては、従来のインストールの方が直感的または使いやすいかもしれません。</li>
  <li><strong>既存インフラへの統合:</strong> Dockerがシステム内の他のサービスで既に使用されている場合、Dockerを通じてPostgreSQLを統合することで、設定を調和させることができます。</li>
</ul>

<p>これらの2つのアプローチは、リソースとセキュリティの観点で比較可能です。このソリューションは高パフォーマンスや特定の設定を必要とするアプリケーションに理想的です。例えば、マネージドサービスでサポートされていない拡張機能を必要とする場合です。サービス料に関していくつかのマネージドサービスよりも経済的である可能性がありますが、システムのセキュリティと適切な動作を保つための継続的な投資が必要です。問題が発生した場合、外部の連絡先もありません。</p>

<p>成長中の企業で内部メンテナンスに必要なリソースを持っている場合、このソリューションが推奨されます。チームが必要なスキルを持ち、継続的なトレーニングのために予算を計画することが重要です。定期的なアップデート、メンテナンス、最適化のための持続的なコミットメントが不可欠です。</p>

<h1 id="開発者向けのpostgresql">開発者向けのPostgreSQL</h1>

<p>最近のPostgreSQLに関するリサーチでは、Postgres.appを使ったインストールがよく推奨されていることに気づきました。個人的には、Homebrewを使用することが私にとっては理想的でした。</p>

<p>ここでは、Macの環境に焦点を当てますが、議論される概念は他のオペレーティングシステムにも容易に適応できます。この考察は、開発者に利用可能なオプションをよりよく理解させ、その作業環境やソフトウェアの好みに基づいて選択を助けることを目的としています。</p>

<h2 id="postgresappを使って">Postgres.appを使って</h2>

<p>Postgres.appを使ったインストールには、いくつかの注目すべき利点があります：</p>

<ul>
  <li><strong>グラフィカルインターフェース:</strong> 基本的ではありますが、データベースとのインタラクションに追加の快適性を提供します。</li>
  <li><strong>スタンドアロンインストール:</strong> 必要な依存関係がすべて統合されており、追加のインストールを避けることができます。</li>
  <li><strong>バージョン柔軟性:</strong> 複数のPostgreSQLバージョンを同時にインストールして実行でき、さまざまなバージョンでのテストや開発を容易にします。</li>
</ul>

<p>このようにして、Homebrewをまだ利用していない開発者にとって、Postgres.appはしばしば最も合理的な選択であり、実験と開発を簡素化します。</p>

<h2 id="homebrewを使って">Homebrewを使って</h2>

<p>Homebrewを介してPostgreSQLをインストールすることの<a href="https://chrisrbailey.medium.com/postgres-on-mac-skip-brew-use-postgres-app-dda95da38d74">よく言及される欠点</a>の一つは、それがパッケージを自動的に更新することです。これには2つの主要な問題が伴います。第一に、ローカルのメジャーバージョンの更新が本番環境からの乖離を引き起こす可能性があり、開発と本番環境をできるだけ類似させておくことが重要です。第二に、メジャーアップグレードがストレージフォーマットの互換性をなくし、データベースが起動できなくなる可能性があります。</p>

<p>しかしながら、Homebrewにはこの問題を回避するための簡単なソリューションがあります。<code class="language-plaintext highlighter-rouge">@</code>と<code class="language-plaintext highlighter-rouge">brew link</code>を使用して使用するメジャーバージョンを指定することができます。また、<code class="language-plaintext highlighter-rouge">pin</code>コマンドを使えば、必要であればマイナーバージョンを固定することもできます：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>postgresql@17
brew pin postgresql@17
brew <span class="nb">link </span>postgresql@17
</code></pre></div></div>

<p>これらのコマンドを適用することで、ローカル環境が本番環境のバージョンを正確に反映することを保証し、互換性の問題を減少させます。Homebrewの自動メジャーバージョンの更新による不便を避け、PostgreSQLの起動を妨げることがなくなります。</p>

<h2 id="railsでの設定">Railsでの設定</h2>

<p>Homebrewを使うにせよ、Postgres.appを使うにせよ、PostgreSQLをアプリケーション（例としてRails）に統合する際には特に設定は必要ありません。デフォルトの権限は、本番環境デプロイのためのベストプラクティスには準じていませんが、開発には問題ありません。私の<code class="language-plaintext highlighter-rouge">database.yml</code>の例を以下に示します：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">default</span><span class="pi">:</span> <span class="nl">&amp;default</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">postgresql</span>
  <span class="na">encoding</span><span class="pi">:</span> <span class="s">unicode</span>
  <span class="c1"># コネクションプーリングに関する詳細は、Rails設定ガイドを参照</span>
  <span class="c1"># http://guides.rubyonrails.org/configuring.html#database-pooling</span>
  <span class="na">pool</span><span class="pi">:</span> <span class="s">&lt;%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %&gt;</span>

<span class="na">development</span><span class="pi">:</span>
  <span class="na">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*default</span>
  <span class="na">database</span><span class="pi">:</span> <span class="s">myapp_development</span>
</code></pre></div></div>

<p>これは、アプリケーション作成時にPostgreSQLをデータベースとして構成することを選ぶだけで、Railsによって生成されたデフォルトの設定であり、何の修正もないものです。その後、次のようにしてデータベースを作成することができます：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rails new myapp <span class="nt">--database</span><span class="o">=</span>postgresql
bin/setup
</code></pre></div></div>

<p>その後、データベースへの接続は単に以下のようにして行います：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rails db
</code></pre></div></div>

<p>そして、PostgreSQL側で何も設定することなく、ユーザーを作成することもなく私のアプリケーションは動作します。</p>

<p>Postgres.appを利用する際には、コマンドラインツールを使用するために、シェルの<code class="language-plaintext highlighter-rouge">PATH</code>変数に適切なパスを<a href="https://postgresapp.com/documentation/cli-tools.html">追加することを忘れないようにしてください</a>。</p>

<h2 id="dockerを使用して">Dockerを使用して</h2>

<p>開発環境におけるDockerとのPostgreSQLの統合は、検討すべき潜在的な代替案を提示します。</p>

<p>すでにDockerを基盤とした環境で、かつその設定に慣れている場合、ちょうど本番環境のように使うことは良い選択です。しかし、これはDockerのインストールを必要とし、Mac上でパフォーマンスの問題を引き起こす可能性があります。これらの問題を避けるために、Docker Desktopの代わりにOrbStackのような代替策を使用することができます。</p>

<p>Dockerを使ったインストールは、すでに使用されている設定である場合に非常に有利です。これにより、すべてのサービスをそれと一緒に起動することが可能です。Dockerに特に投資していない場合は、Postgres.appやHomebrewがより良い代替になるかもしれません。</p>

<p>最終的に、Dockerを使用することで前述のシンプルなアプリケーション設定を利用することが可能ですが、これはDockerがどのようにPostgreSQLをインストールしたかの設定次第です。</p>

<h1 id="結論">結論</h1>

<p>最終的に、PostgreSQLのインストール方法の選択は、パフォーマンス、セキュリティ、およびリソース管理に関する特定のニーズの徹底的な分析によって導かれるべきです。小規模なプロジェクトに取り組んでいる開発者は、複雑なアプリケーションを管理する企業と同じ期待を持っていないでしょう。</p>

<p>決断を下す前に、プロジェクトの成長の可能性を評価しましょう。現在のニーズを満たし、将来の進化に適応するソリューションを選択してください。</p>

<p>プロジェクトの立ち上げ時や個々の開発者には、マネージドデータベースが大きな快適さを提供することがあります。逆に、特定のパフォーマンス要件と必要な技術資源を持つ企業は、専用サーバーやDockerによるインストールを好むことが多いでしょう。</p>

<p>すべてのケースで優れた普遍的なソリューションは存在しません。これらの要素を慎重に評価することによって、自分の環境に最も適したPostgreSQLのインストールソリューションを選択してください。プロジェクトの進展に応じて選択を調整しましょう。</p>]]></content><author><name></name></author><category term="PostgreSQL" /><category term="Homebrew" /><category term="Docker" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">2024年にプログレッシブエンハンスメントを継続する理由？</title><link href="/rails/hotwire/stimulus/turbo/2024/11/05/pourquoi-continuer-a-faire-du-progressive-enhancement.html" rel="alternate" type="text/html" title="2024年にプログレッシブエンハンスメントを継続する理由？" /><published>2024-11-05T06:00:00+00:00</published><updated>2024-11-05T06:00:00+00:00</updated><id>/rails/hotwire/stimulus/turbo/2024/11/05/pourquoi-continuer-a-faire-du-progressive-enhancement</id><content type="html" xml:base="/rails/hotwire/stimulus/turbo/2024/11/05/pourquoi-continuer-a-faire-du-progressive-enhancement.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>プログレッシブエンハンスメントは、Webデザインの手法で、まず機能のミニマリストかつ堅牢なバージョンを作成します。つまり、2000年代のブラウザでも使用可能なものです。その後、その上に現代的な機能を段階的に追加していきます。</p>

<p>これを達成するために、まず最小限かつ標準的なHTMLコードでページを書き、同様に最小限かつ標準的な指示を備えたCSSスタイルシートを関連付けます。これにより、接続が不十分でJavaScriptが無効化されていても、瞬時に読み込まれる機能的なページが得られます。</p>

<p>ユーザーエクスペリエンスを向上する非必須機能（フォント、インタラクティブな動作、ビジュアルエフェクト）は段階的に追加され、これらの強化機能が有効でなくても基本的なページ機能が動作するようにします。</p>

<h1 id="2024年の現状">2024年の現状</h1>

<p>プログレッシブエンハンスメントを使用する一般的に受け入れられている<a href="https://piccalil.li/blog/its-about-time-i-tried-to-explain-what-progressive-enhancement-actually-is/">動機</a>は、悪化した状況でも許容できるユーザーエクスペリエンスを提供することです。</p>

<p>しかし2024年には、悪化した状況での少数の人々の体験を気にせずにサービスを開始することが完全に可能です。このため、20年以上にわたり多くの開発者がJavaScriptを有効にすることを要求し、一般にユーザーがサイトと対話できるようになる前に大量のJavaScriptをダウンロードする必要がある技術を選んできました。</p>

<p>このアプローチは疑いなくビジネスの成功を許します。たとえ一部のユーザーが取り残されたとしても、それがサービスの成功を妨げるわけではありません。</p>

<p>もちろん、私は誰も取り残さないことを開発における方針としていますが、それに比べても私にはこのアプローチを採用するもっと重要な理由があります。</p>

<h1 id="プログレッシブエンハンスメントの理由">プログレッシブエンハンスメントの理由</h1>

<p>正しい理由とは、あなた自身を納得させるか、またはチーム全体や役員を説得してこのアプローチに切り替えさせる理由です。</p>

<p>全ユーザーの対象を98%から99%に引き上げられると言ってこれらすべての人々を説得しようとしているならば、それが非常に確立された多国籍企業でない限り、成長のための最後のレバーとなる可能性があります。そうでない場合、納得させる可能性は低いです。</p>

<p>それでも、特定の大部分のユーザーが時折悪化した状況に直面する可能性があると納得させても（公共の交通機関で携帯電話を使用する人を考えてみてください）、それで彼らの優先度が変わるわけではありません。</p>

<p>しかし、私にとって最も興味深いことは、この技術がよりシンプルで維持しやすいコードに繋がることです。</p>

<h1 id="プログレッシブエンハンスメントはコードを改善する">プログレッシブエンハンスメントはコードを改善する</h1>

<p>私にとって良い理由は、このアプローチがコード品質を改善し、アプリケーション内の多くの問題を回避することです。それをここで説明します。</p>

<blockquote>
  <p>実際のデリバラブル媒体で — Webで — サイクル/イテレーション/スプリント作業を行い、根本にプログレッシブエンハンスメントを取り入れることにより — 私が約束します — コードベースは小さく、UIはシンプルになり、ユーザーは幸福になります！</p>

  <p><a href="https://piccalil.li/author/andy-bell"><em>Andy Bell</em></a></p>
</blockquote>

<h2 id="javascriptの量を減らします">JavaScriptの量を減らします</h2>

<p>まず、JavaScriptは既存の体験を強化するためだけに使用します。
このようにして、その体験はWebの標準機能だけで実現されます。
デフォルトでは、<a href="/rails/actioncontroller/actionview/2024/10/15/les-bonnes-pratiques-avec-les-formulaires-rails.html">リンクとフォーム</a>を使用してサーバーと通信します。大部分の機能ではこれで十分で、満足のいく体験を実現するために何も追加する必要はありません。</p>

<p>しかし、時には体験を最適化したい場合もあります。例えば、オートコンプリート付きのフィールドを考えます。
この原則は、入力中に提案リストを表示することです。
<a href="https://gomakethings.com/how-to-create-an-autocomplete-input-with-only-html/">このような機能は<del>JavaScriptなしでは実現不可能です</del>。JavaScriptを頻繁に要求します</a>、各入力で動作をトリガーする必要があるためです。サーバーとのやり取りが必要な場合、単純なHTMLでは不十分です。</p>

<p>しかし、プログレッシブエンハンスメントの原則に従ってこの種の機能を実装することで、コードアーキテクチャが簡素化されます。</p>

<p>JavaScriptなしでこのような機能がどのように見えるかを想像してみてください。
入力フィールドと最初は空の提案リストを表示できます。
ユーザーが入力するたびに、提案を確認したいと思います。
これを行うために、提案を瞬時に表示する代わりに、ユーザーは専用の提案読み込みボタンをフォームで有効化して表示することができます。
JavaScriptなしの場合、リストを含むページ全体がリロードされます。
ユーザーはリストからアイテムを選び、フォームを最終的に完成させます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:product</span>
  <span class="nb">attr_accessor</span> <span class="ss">:product_name</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">search</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">none</span> <span class="k">if</span> <span class="n">query</span><span class="p">.</span><span class="nf">blank?</span>

    <span class="n">where</span><span class="p">(</span><span class="s1">'name like :query'</span><span class="p">,</span> <span class="ss">query: </span><span class="s2">"</span><span class="si">#{</span><span class="n">query</span><span class="si">}</span><span class="se">\%</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OrdersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">new</span>
    <span class="vi">@order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="vi">@order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:order</span><span class="p">].</span><span class="nf">permit!</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="ss">:commit</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="vi">@order</span><span class="p">.</span><span class="nf">save</span>
      <span class="n">redirect_to</span> <span class="vi">@order</span>
    <span class="k">else</span>
      <span class="n">render</span> <span class="ss">:new</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%=</span> <span class="n">form_with</span> <span class="ss">model: </span><span class="vi">@order</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;fieldset&gt;</span>
    <span class="nt">&lt;legend&gt;</span>Todo<span class="nt">&lt;/legend&gt;</span>

    <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">text_field</span> <span class="ss">:name</span> <span class="cp">%&gt;</span>

    <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">text_field</span> <span class="ss">:product_name</span><span class="p">,</span>
                     <span class="ss">list: </span><span class="s1">'product-suggestions'</span><span class="p">,</span>
                     <span class="ss">value: </span><span class="n">params</span><span class="p">.</span><span class="nf">dig</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="ss">:product_name</span><span class="p">)</span> <span class="cp">%&gt;</span>

    <span class="nt">&lt;datalist</span> <span class="na">id=</span><span class="s">"product-suggestions"</span><span class="nt">&gt;</span>
      <span class="cp">&lt;%</span> <span class="no">Product</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="vi">@order</span><span class="p">.</span><span class="nf">product_name</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">product</span><span class="o">|</span> <span class="cp">%&gt;</span>
        <span class="cp">&lt;%=</span> <span class="n">content_tag</span> <span class="ss">:option</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="ss">value: </span><span class="n">product</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>
      <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
    <span class="nt">&lt;/datalist&gt;</span>

    <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">submit</span> <span class="s1">'Search'</span><span class="p">,</span> <span class="ss">name: </span><span class="s1">'autocomplete'</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/fieldset&gt;</span>

  <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">submit</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>その後、この体験を強化するためにJavaScriptを使用できます。このアプローチを使用する利点は、追加するJavaScriptが非常に少ないことです。Hotwire Turboのようなテクノロジーを使用することで、自分でJavaScriptを追加する必要さえなく、フォームでほんの少し設定するだけです。JavaScriptはボタンを非表示にし、入力に基づいた動作をトリガーします。この動作にはリストの読み込みが含まれ、次に現在のページでリストが置き換えられます。リストの読み込みは、更新された現在のページを取得することで行われます（サーバー部分の更新を要求せず）、または提案を含むページの部分的なバージョンを取得します。</p>

<p>注目すべきは、この例では、コントローラーが商品提案を表示するために適応を必要とせず、<code class="language-plaintext highlighter-rouge">params[:commit]</code>が定義されているかどうかをチェックしてインタラクティブな動作を処理するだけです。</p>

<p>このアプローチがアプリケーション内のJavaScript量をどのように減らすことができるかを示しました。次に、JavaScriptの削減がどのようにアプリケーションの保守を容易にするかを見ていきます。</p>

<h1 id="コードの保守が容易になります">コードの保守が容易になります</h1>

<p>Railsアプリケーションでは、JavaScriptコードはWebブラウザでの実行を必要とするため、テストが難しく、複雑になります。一方で、バックエンドのコードはサーバー上でブラウザを介さずにネイティブに実行されるため、テストが簡単です。このため、JavaScriptコードをテストする際はテストの実行が長くなります。</p>

<p>プログレッシブエンハンスメントを使用すると、生成されるJavaScriptコードはより汎用的でテストが容易になります。ビジネスロジックへの依存がなくなり、コードはアプリケーション内の他の場所で再利用される可能性があります。この再利用のスノーボール効果により、アプリケーション内のJavaScriptコードがさらに削減され、正のスパイラルが生まれます。</p>

<p>もちろん、JavaScriptコード（より正確にはブラウザで直接実行されるコード）が本質的に問題であるわけではありません。ただ、その系統的な使用がシステムを複雑にします。この複雑性を減らすことで、アプリケーションのメンテナンス性が向上します。</p>

<h1 id="第2の例">第2の例</h1>

<p>テキストをクリップボードに自動でコピーするためには、JavaScriptが必要です。</p>

<p>しかし、JavaScriptなしで同等の機能を設計することができます。具体的には、コピーしたいテキストを表示し、ユーザーに自分でオペレーティングシステムの機能を使ってコピーするよう提案することです。</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%</span> <span class="k">if</span> <span class="vi">@order</span><span class="p">.</span><span class="nf">product</span> <span class="cp">%&gt;</span>
  URL <span class="cp">&lt;%=</span> <span class="n">text_field_tag</span> <span class="s1">''</span><span class="p">,</span> <span class="n">url_for</span><span class="p">(</span><span class="vi">@order</span><span class="p">.</span><span class="nf">product</span><span class="p">)</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>これはユーザーのニーズを満たします。この提案された解決策は非常に基本的ですが、驚くほど効果的です。</p>

<p>その後、この基本機能を拡張して、テキストの選択とコピーが自動で行われるようにJavaScriptを用いることができます。</p>

<p>その原則は、テキストを（オプションで）非表示にしながら、ページのコード内に保持し、ユーザーのクリップボードにコピーをトリガーするボタンと、成功メッセージを表示することです。</p>

<p>したがって、JavaScriptが利用できない場合、サイトは単純にテキストを表示し、自分でコピーするように指示メッセージを表示します。機能は依然としてアクセス可能です。そしてJavaScriptが利用可能になると、ユーザーはテキストを自動でコピーする単純なボタンを目にすることができます。</p>

<p>この例でも原則は同じです：JavaScriptなしで機能的な基本バージョンを作成し、JavaScriptを用いてユーザー体験を強化してインタラクティビティを追加することです。先述した利点すべてがここでも見られます：機能は常にアクセス可能であり、拡張されたバージョンは再利用可能で、容易に保守でき、非常に少ない追加コードが必要です。</p>

<h1 id="複雑なほど利点が大きくなる">複雑なほど利点が大きくなる</h1>

<p>前述の例は非常に簡単でしたが、このアプローチの興味を示すのに十分でした。</p>

<p>サーバーとのインタラクションを追加することで、もう少し例を押し進めてみましょう。</p>

<p>今度は、ユーザーがオートコンプリート機能を利用してデータベースから商品を名前で選択することができるようにします。その後、顧客にメールで送信するためにその商品のリンクをコピーしたいと考えるでしょう。</p>

<p>最初の例と同様に、ユーザーの入力はサーバーに送信され（フォームボタンを介して、または自動的に）、ブラウザは結果のリストを取得します。</p>

<p>今回は、ユーザーが結果を選択した際に、その結果に対応するリンクをコピーするオプションを提供したいと思います。</p>

<p>これを行うために、同じアプローチを使用してフォームに「リンクを表示する」ボタンを追加してインタラクションをトリガーします。商品が選択されると、ユーザーはこのボタンを有効化し、リンクが含まれるページがリロードされ、ユーザーはそれをコピーすることができます。</p>

<p>ここでも、商品が選択された際にこの動作を自動的にトリガーすることで、ユーザー体験を向上させることができます。その後、ユーザーはリンクをクリップボードにコピーするためのボタンを目にします。</p>

<p>JavaScriptがない場合、ユーザーはフォームのボタンを使用してインタラクティブな動作をトリガーします。JavaScriptがある場合、動作はユーザーのアクションによって自動的にトリガーされ、より自然な体験ができます。</p>

<p>私たちのアプローチでは、これらのボタンを既存のフォームに追加しています。サーバーが情報を取得し、ユーザーの入力が新しいページにリロードされた際も保持されるようにするために、これを行うことが重要です。JavaScriptでは、ページを部分的にリロードして問題を回避することができますが、JavaScriptがない場合、ページのリロードは必要不可欠です。</p>

<p>また、各動作には独自のボタンがあります。このアプローチにより、異なる動作の再利用や組み合わせができます。サーバーが必要に応じて適応できる場合もありますが、通常は、どのボタンを有効化しても、利用可能なすべてのインタラクションがトリガーされます。</p>

<p>ブラウザの通常のリクエスト/レスポンスプロセスを利用することで、エラー管理がより適切に行えます。例えば、サーバーエラーやネットワーク問題でページの読み込みができなくなった場合、デフォルトのJavaScriptインタラクションでは単に失敗してしまうかもしれないところで、クライアントに明確なメッセージが表示されます。</p>

<p>別のアプローチを取っていた場合、同時に動作を組み合わせ、サーバーにリクエストを送り、JavaScriptでしか処理できない形式のレスポンスを使用する方が自然だと考えられたかもしれません。最終的に、その結果は堅牢性が低く、信頼性が低く、メンテナンスしづらいものであったと思われます。</p>

<p>結論として、この例は、ブラウザ内で非常に少ないJavaScriptコードを追加することで複雑なインタラクションを設計するためにこのアプローチを容易に使用できることを示しています。しかし、クライアント側で節約できる分、サーバー側で必要な対応が増えます。</p>

<p>たしかに、フォームは複数の機能的ニーズに対応しなければならない：</p>

<ul>
  <li>異なるアクション（オートコンプリート、リンク表示、最終バリデーション）を区別する。</li>
  <li>フォームを最終的にバリデートしない場合、ユーザー入力を保持しながら再表示し、関連するオブジェクトを実際に作成しない。</li>
  <li>商品が選ばれた際、サーバーが返すページは、その商品のリンクをコピーするための設定と、クリップボードコピーJavaScript動作を有効化する設定を含んでいなければならない。</li>
</ul>

<p>これらの追加動作をハンドリングするためのサーバー側の適応が確かに必要です。しかし、これは管理可能な欠点です：</p>

<ul>
  <li>適応は実際にはシンプルに実装でき、ビューコードへのシンプルな追加が異なるインタラクションのための新しいデータを伝えるのに十分です。</li>
  <li>サーバーが受け取ったパラメーターでフォームを再活性化させ、入力を維持します。</li>
  <li>個々のアクションを区別する必要はなく、最終的なバリデーションと単なるインタラクション要求を区別するだけで十分です。このアプローチは簡単に一般化され、追加コードの量はインタラクティブな動作の数に応じて増加することはありません（すべて1つのコントローラー変更でハンドルされます）。</li>
  <li>別のアプローチであってもサーバー側の適応が必要です（たとえば、リストやコピーするリンクを返すためのAPI）。プログレッシブエンハンスメントが要求する適応はより汎用的で、したがって保守しやすいです。</li>
</ul>

<p>このアプローチは機能の種類に依存せず、どの種類のインタラクティブな動作にも一般化できます。さらに、機能自体が汎用的であり、異なるコンテキストで再利用でき、ユーザー環境の品質に応じた最適な体験を提供するために組み合わせることができます。</p>

<h2 id="結論">結論</h2>

<p>プログレッシブエンハンスメントは新しい概念ではありませんが、依然として重要です。標準のウェブ技術を使用して必要なすべての機能を設計し、JavaScriptを追加することでユーザー体験を豊かにすることができます。特にモバイルでユーザーが悪化した状態を体験することを考慮せずに多くのサービスが開始されているにもかかわらず、プログレッシブエンハンスメントを採用することで、より広範囲のユーザーにリーチし、満足のいくユーザー体験を提供することができます。</p>

<p>このアプローチの利点は多数あります。JavaScriptを削減することで、コードは軽量でシンプルになり、保守が容易になります。メンテナンスが容易になるだけでなく、JavaScriptコード自体がより汎用的で再利用可能になります。この方法は、標準のブラウザのリクエスト/レスポンスサイクルを使用することで信頼性が高くなり、デフォルトでエラーハンドリングが改善されます。</p>

<p>最後に、プログレッシブエンハンスメントを採用することは、サーバー側の調整を要求しますが、それらはシンプルで汎用的であり、コードのスケーラビリティと保守性を促進します。これらの原則を統合することで、開発者は高性能でアクセス可能なアプリケーションを設計することが可能になります。</p>]]></content><author><name></name></author><category term="Rails" /><category term="Hotwire" /><category term="Stimulus" /><category term="Turbo" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">シンプルで洗練されたRailsフォームのためのベストプラクティスガイド</title><link href="/rails/actioncontroller/actionview/2024/10/15/les-bonnes-pratiques-avec-les-formulaires-rails.html" rel="alternate" type="text/html" title="シンプルで洗練されたRailsフォームのためのベストプラクティスガイド" /><published>2024-10-15T16:30:00+00:00</published><updated>2024-10-15T16:30:00+00:00</updated><id>/rails/actioncontroller/actionview/2024/10/15/les-bonnes-pratiques-avec-les-formulaires-rails</id><content type="html" xml:base="/rails/actioncontroller/actionview/2024/10/15/les-bonnes-pratiques-avec-les-formulaires-rails.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>Railsアプリケーションでは、ビジネスロジックや避けることができるマークアップを追加すると、<a href="https://guides.rubyonrails.org/action_controller_overview.html">コントローラー</a>や<a href="https://guides.rubyonrails.org/action_view_overview.html">ビュー</a>が複雑化することがあります。</p>

<p>この記事では、Railsの<a href="https://api.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html">FormBuilders</a>と<a href="https://guides.rubyonrails.org/active_record_basics.html">ActiveRecord</a>の<a href="https://guides.rubyonrails.org/association_basics.html">アソシエーション</a>を使用して、フォームコードを読みやすく保つための戦略を探ります。</p>

<h1 id="問題提起">問題提起</h1>

<p>私が働いてきたほとんどの企業では、コントローラーとビューが過剰になっていることが多々あり、数多くの努力にもかかわらず、この問題を完全になくすことはできませんでした。</p>

<p>理想的なコントローラーは、次のようなアクションを持つべきだと考えます：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">new</span>
    <span class="vi">@todo</span> <span class="o">=</span> <span class="no">Todo</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="vi">@todo</span> <span class="o">=</span> <span class="no">Todo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">todo_params</span><span class="p">)</span>

    <span class="k">if</span> <span class="vi">@todo</span><span class="p">.</span><span class="nf">save</span>
      <span class="n">redirect_to</span> <span class="ss">action: :index</span><span class="p">,</span>
                  <span class="ss">flash: </span><span class="p">{</span> <span class="ss">notice: :successfully_saved</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">render</span> <span class="ss">:new</span><span class="p">,</span>
             <span class="ss">flash: </span><span class="p">{</span> <span class="ss">error: :could_not_be_saved</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>このスニペットでは、アクションコードは標準的で、ビジネスロジックを含んでいません。コードはシンプルで理解しやすいです。</p>

<p>しかし、関連するビジネスロジックは明示的ではなく、モデルに実装され、ビューに表示ロジックが組み込まれます。</p>

<p>時間が経つと、さまざまな理由で、連続する開発がコントローラを自然に複雑化させる傾向があります：</p>

<ul>
  <li>関連モデルの更新を要求されることがあり、そのため、いくつかの開発者はこれらのアソシエーションの設定を（例：空のオブジェクトを作成する）コントローラーに追加して、フォームの表示を簡単にするかもしれません。</li>
  <li>モデルに直接変換されない特定の動作を有効にしたい場合があります。このためには、モデル構造とは独立したパラメータをフォームに追加し、コントローラでその値を検出して特定のロジックを実行します。</li>
  <li>データ量の増加は、フィルター（またはスコープ）を使用することにつながり、クエリが時折複雑化します。これらのフィルターは時には条件付きで適用する必要があります。このロジックがコントローラーに追加されると、すぐに悪化する可能性があります。</li>
  <li>複雑な領域での習熟度が不足した開発者が、グラフの特定のオブジェクトを個別に保存することを結果的に行うことを見てきました。これがデータの不整合につながる可能性があることを強調しておきます。一般的に、アソシエーションとネストしたフォームの適切な使用はこれを避けるのに役立ちます。</li>
  <li>リストは続きます：他にも、メールやその他の通知の送信、オートコンプリートを管理するための<a href="https://medium.com/podiihq/understanding-rails-routes-and-restful-design-a192d64cbbb5">REST</a>標準に準拠しないアクションなども考えられます。</li>
</ul>

<p>ビューもまた、複雑さを逃れることはできません。対話型の動作を追加するには、Stimulusコントローラーを介して例えばJavaScriptコードを統合する必要があり、その設定がコードの読みやすさを乱し、複雑化することがあります。ユーティリティCSSクラスの使用や、標準のフォームとTurboを使用する代わりにサーバーとの通信にJSONデータを使用することも、この複雑さに寄与することがあります。時にはフォーム構造を適応させ、Turboを使用する方が賢明です。その他の複雑さの例としては、冗長または類似のコード、既存のデータ構造を考慮せずにビジネス要件に基づいて設計されたフォームが含まれます。</p>

<h1 id="解決策">解決策</h1>

<p>実際には、この問題はRailsが初めから提供しているツールを使用して比較的簡単に解決することができます。解決策は、いくつかの重要なRails機能を習得することにあります：</p>

<ul>
  <li>FormBuilders</li>
  <li>アソシエーション</li>
  <li><a href="https://guides.rubyonrails.org/action_view_helpers.html">ヘルパー</a></li>
  <li><a href="https://guides.rubyonrails.org/active_record_callbacks.html">コールバック</a></li>
  <li>コントローラーとモデル内の<a href="https://codefol.io/posts/How-Does-Rack-Parse-Query-Params-With-parse-nested-query/">HTTPパラメータ管理</a></li>
</ul>

<h3 id="全インタラクティビティを管理するためのrailsフォーム">全インタラクティビティを管理するためのRailsフォーム</h3>

<p>Railsのアソシエーションは非常に強力です。いくつかの開発者は、フォームを扱うのは少し複雑であまり柔軟ではないと見ています。実際には、ブラウザとサーバー間のすべてのインタラクションはフォームで実行できます。</p>

<p>私が観察してきたフォームの使用への障壁の一つは、フォームを単なる<a href="https://fr.wikipedia.org/wiki/CRUD#:~:text=L'acronyme%20informatique%20anglais%20CRUD,informations%20en%20base%20de%20donn%C3%A9es.">CRUD</a>と見なしていることです。基本的に、Railsの<a href="https://guides.rubyonrails.org/command_line.html#bin-rails-generate">scaffold</a>、つまり、テーブルのフィールドを反映するフォームを作成し、それをデータベースに保存することです。</p>

<p>しかし、フォームを用いてアソシエーションを駆使することで、サーバーとの任意のインタラクションをモデル化することができます。Hotwireを追加することで、ユーザーはフォームを扱っていることさえ意識せず、単なる技術的な細部に変えます。</p>

<p>もちろん、少し誇張していますが、実際には、おそらくアソシエーションを管理するための<code class="language-plaintext highlighter-rouge">fields_for</code>をご存知でしょう。<code class="language-plaintext highlighter-rouge">fields_for</code>はRailsのメソッドで、関連するオブジェクトのためのフォームフィールドを作成することを可能にし、これにより複雑なモデル関係の管理が容易になります。例えば、注文編集フォームで複数の関連商品を入力するために<code class="language-plaintext highlighter-rouge">fields_for</code>を使用できます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= form_for @order do |f| %&gt;
  &lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:name</span> <span class="o">%&gt;</span>
  <span class="o">&lt;</span><span class="sx">%= f.text_field :name %&gt;

  &lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">fields_for</span> <span class="ss">:items</span> <span class="k">do</span> <span class="o">|</span><span class="n">fi</span><span class="o">|</span> <span class="sx">%&gt;
    &lt;%= fi.label :name %&gt;</span>
    <span class="o">&lt;</span><span class="sx">%= fi.text_field :name %&gt;

    &lt;%=</span> <span class="n">fi</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:quantity</span> <span class="o">%&gt;</span>
    <span class="o">&lt;</span><span class="sx">%= fi.number_field :quantity %&gt;

    &lt;%# 既存オブジェクトの更新 %&gt;
    &lt;%=</span> <span class="n">fi</span><span class="p">.</span><span class="nf">hidden_field</span> <span class="ss">:id</span> <span class="o">%&gt;</span>
  <span class="o">&lt;</span><span class="sx">% end </span><span class="o">%&gt;</span>

  <span class="o">&lt;</span><span class="sx">%= f.submit %&gt;
&lt;% end %&gt;
</span></code></pre></div></div>

<h3 id="fields_forの複雑さ"><code class="language-plaintext highlighter-rouge">fields_for</code>の複雑さ</h3>

<p><code class="language-plaintext highlighter-rouge">fields_for</code>の使用は、フォーム内でいくつかのケースを考慮する必要があるため、最初は少し面倒に思えるかもしれません：</p>

<ul>
  <li>データベースに既に保存されているオブジェクトの表示と更新。</li>
  <li>一つまたは複数の新規オブジェクトの作成可能性。</li>
</ul>

<p>ActiveRecordでは、これをほぼ透明に扱うことができますが、保存されたオブジェクトとまだ保存されていないオブジェクトの管理は同じではありません。Railsは強力ですが、開発者は常にいくつかの微妙な点を念頭に置いておく必要があります。そうしないと、混乱してコントローラを調整して動かすことで諦める可能性があります。</p>

<p>これらの微妙な点の一部は、見逃すと本当に問題になります。おそらくいくつかはご存知でしょう。特に、アソシエーションを更新するためのhiddenフィールドを忘れることを考えています。この場合、安全のために更新されたオブジェクトを適切にフィルタリングしてください。モデル内では、<code class="language-plaintext highlighter-rouge">reject_if</code>を使用して、更新されたオブジェクトが既存のアソシエーションの一部か、まだデータベースに存在しないことを確認します。別の例としては、モデル内で<code class="language-plaintext highlighter-rouge">accepts_nested_attributes_for</code>を設定することを忘れることです。</p>

<p>他にもいくつかあり、それらが増えるにつれて混乱が増します。</p>

<h3 id="チェックボックスと_destroyを使ったアソシエーションの管理コントローラーを複雑にせずに">チェックボックスと_destroyを使ったアソシエーションの管理（コントローラーを複雑にせずに）</h3>

<p>オブジェクトとそのアソシエーションを持つフォームを用意したら、より多くのケースを扱うことができます。</p>

<p>しかし、データストレージとフォームの等価性を壊すとさらに興味深くなります。</p>

<p>例えば、オンライン販売アプリケーションを持っているとします（<code class="language-plaintext highlighter-rouge">Order</code>モデルを<code class="language-plaintext highlighter-rouge">has_many :services</code>アソシエーションと一緒に考えます）。注文時には、チェックボックス（またはトグル）を使って、どのサービスを有効にするかを選択するだけです。</p>

<p>単純なアプローチは、フォームに追加属性を追加し、コントローラ側でパラメータを取得し、対応するサービスを作成/削除することを含むかもしれません。</p>

<p>このコードをコントローラーに置くのを避けるために、モデルに対応するアクセサを作成することができます（またはビューのロジックで、ビジネスロジックではないため、<a href="https://jetthoughts.com/blog/cleaning-up-your-rails-views-with-view-objects-development/">View Object</a>内に作成します）。それはよりクリーンで、同様に機能します。</p>

<p>このアプローチはもちろん機能しますが、ビジネスの価値をほとんど持たない多くのプランビングロジックを書くことを伴います。</p>

<p>関連付けに<code class="language-plaintext highlighter-rouge">_destroy</code>属性を使用することでこれらの問題を解決します。注文に利用可能なすべてのサービスを正しいパラメータで初期化するためのいくつかのロジックはまだありますが、デフォルトでサービスを有効にしないためには（オプトイン）、<code class="language-plaintext highlighter-rouge">_destroy</code>をtrueに設定し、デフォルトでサービスを有効にするためには（オプトアウト）設定しない必要があります。モデル側で<code class="language-plaintext highlighter-rouge">after_initialize</code>コールバックを使って行うことができます。条件付きで<code class="language-plaintext highlighter-rouge">Order.new(build_services: true)</code>のように行います。<code class="language-plaintext highlighter-rouge">build_services</code>はコールバックを有効にするかどうかを示す<code class="language-plaintext highlighter-rouge">attr_accessor</code>です。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:services</span>

  <span class="n">accepts_nested_attributes_for</span> <span class="p">\</span>
    <span class="ss">:services</span><span class="p">,</span>
    <span class="ss">allow_destroy: </span><span class="kp">true</span><span class="p">,</span>
    <span class="ss">reject_if: :belongs_to_foreign_record?</span>

  <span class="nb">attr_accessor</span> <span class="ss">:build_services</span>
  <span class="n">after_initialize</span> <span class="ss">:build_services_records</span><span class="p">,</span> <span class="ss">if: :build_services</span>

  <span class="k">def</span> <span class="nf">build_services_records</span>
    <span class="no">Service</span><span class="o">::</span><span class="no">KINDS</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">kind</span><span class="o">|</span> <span class="n">services</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="n">kind</span><span class="p">:)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">belongs_to_foreign_record?</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">attributes</span><span class="p">[</span><span class="s1">'id'</span><span class="p">].</span><span class="nf">present?</span> <span class="o">&amp;&amp;</span>
      <span class="n">services</span><span class="p">.</span><span class="nf">ids</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="s1">'id'</span><span class="p">].</span><span class="nf">to_i</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>この方法でコントローラーは、モデルの実装詳細を知る必要がなくなります（strong_parametersを忘れない場合）。少しだけ標準から外れていますが、実際には問題ありません。</p>

<p>ビュー側では、<code class="language-plaintext highlighter-rouge">f.fields_for :services</code>を使ってそれを処理できます。そして、<code class="language-plaintext highlighter-rouge">_destroy</code>に対応するチェックボックスをCSSで反転して表示します（<code class="language-plaintext highlighter-rouge">_destroy</code>がtrueの場合、ボックスはチェックされず、その反対も同様です）。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= f.fields_for :services do |fs| %&gt;
  &lt;%=</span> <span class="n">fs</span><span class="p">.</span><span class="nf">hidden_field</span> <span class="ss">:id</span> <span class="o">%&gt;</span>
  <span class="o">&lt;</span><span class="sx">%= fs.check_box :_destroy %&gt;
&lt;% end %&gt;
</span></code></pre></div></div>

<p>フォームのパラメータがコントローラからモデルに送られると、<code class="language-plaintext highlighter-rouge">_destroy</code>がtrueに設定されたアソシエーションが削除されます。したがって、アクティブ化されたサービスのみが注文に関連付けられます。</p>

<p>ここで示したのは、Railsのロジックを少し曲げることで何ができるかを示す一例に過ぎません。</p>

<p>些細なことに見えるかもしれませんが、この手法は余分なコード（肥大化）を制限するのに役立ちます。比較的簡単で理解しやすいコードを維持しながら、複雑な機能を実装することができます。このロジックは少し込み入っているかもしれませんが、これらのパターンは異なる状況に適用できるため、アプリケーションは成長し続け、さらに長い時間修正されていなくてもアクセス可能なコードを維持できます。</p>

<p>私たちのアプリケーションでは、このアプローチを使用して、注文に関連付けられたサービスを構成しています。これによってビューの多くのコードを削除し、コントローラーを簡素化することができました。</p>

<h3 id="カスタムformbuilderを使用した冗長性の排除">カスタムFormBuilderを使用した冗長性の排除</h3>

<p>ActiveAdminは、<code class="language-plaintext highlighter-rouge">formtastic</code>を使用してフォームを生成します。これは少し風変わりで非常に簡潔な構文で、ActiveAdminでフォームを作成することができます。カスタマイズする必要があった場合には、この構文と苦闘したことがあるかもしれません。</p>

<p>おそらく、別のform builderである<code class="language-plaintext highlighter-rouge">simple_form</code>もご存知でしょう。</p>

<p>しかし実際には、アプリケーションに自分のform builderを持つことで、よりクリーンなビューが可能になります。</p>

<p>利点は、form builderの作成者が行った選択に適応するのではなく、自分のアプリケーションのニーズに応じて調整できる点で、本当はそれほど難しいことではありません。</p>

<p>多くの場合、フォームを書くときに一般的な方法があります。ほぼすべてのフォームに似たレイアウトやスタイルを適用します（または少なくともいくつかの異なるスタイルをうまく使い分けます）。</p>

<p>例えば、ラベルを使用し、その後にフィールドを使用し、場合によってはCSSクラスを追加してdivにカプセル化します（Tailwindを好む場合や、セマンティックHTML/CSSアプローチを好む場合でも）。</p>

<p>Railsのデフォルトのヘルパーは、ActiveRecordを使ってHTMLフィールドを再現します。そのため、Railsのヘルパーにだけ依存している場合、ビューは冗長で反復的になります。必ずその中にdivとそのクラスがあり、それにラベルとフィールドが含まれています。</p>

<p>FormBuilder内で、Railsのヘルパーをオーバーライドする（または別のものを横に作成します）ことで、一度にすべてを生成できます。これにより、ビューはずっとクリーンになります。異なるバージョンを作成する必要がある場合は、別のヘルパーを追加するか、追加オプションをヘルパーに追加することもできます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ApplicationFormHelper</span>
  <span class="k">def</span> <span class="nf">semantic_form_with</span><span class="p">(</span><span class="ss">model: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">scope: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">url: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">format: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">merged_options</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">builder: </span><span class="no">ApplicationFormBuilder</span> <span class="p">}.</span><span class="nf">merge</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="n">form_with</span><span class="p">(</span><span class="n">model</span><span class="p">:,</span> <span class="n">scope</span><span class="p">:,</span> <span class="n">url</span><span class="p">:,</span> <span class="nb">format</span><span class="p">:,</span> <span class="o">**</span><span class="n">merged_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ApplicationFormBuilder</span> <span class="o">&lt;</span> <span class="no">ActionView</span><span class="o">::</span><span class="no">Helpers</span><span class="o">::</span><span class="no">FormBuilder</span>
  <span class="k">def</span> <span class="nf">text_field</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">_wrapped_field</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="k">super</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="n">_wrapped_field</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="n">object</span><span class="p">.</span><span class="nf">public_send</span><span class="p">(</span><span class="nb">method</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">_wrapped_field</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="vi">@template</span><span class="p">.</span><span class="nf">content_tag</span><span class="p">(</span><span class="ss">:p</span><span class="p">)</span> <span class="k">do</span>
      <span class="vi">@template</span><span class="p">.</span><span class="nf">safe_join</span> <span class="p">[</span><span class="n">label</span><span class="p">(</span><span class="nb">method</span><span class="p">),</span> <span class="n">value</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>次に問題となってくるのがStimulusコントローラーです。Stimulusの構文は特に冗長で、書くのは比較的簡単ですが、読み解くのは時にかなり消化不良になります。</p>

<p>例えば、アソシエーション内で動的にオブジェクトを追加/削除したい場合、<a href="https://www.stimulus-components.com">Stimulus Components</a>の<code class="language-plaintext highlighter-rouge">nested-form</code>を使用したいかもしれません。構文は比較的まっすぐですが、簡素化できるでしょう：</p>

<ul>
  <li>機能を有効にするためにフォームタグにデータ属性を追加する必要があります。</li>
  <li>テンプレートの設定が多くのタグを伴います。</li>
</ul>

<p>ヘルパーを追加することによって（例えば<code class="language-plaintext highlighter-rouge">f.has_many :items</code>を使用するのに使用できる）、次のことができます：</p>

<ul>
  <li>デフォルトの伝説を持つ<code class="language-plaintext highlighter-rouge">fieldset</code>を自動的に生成します。</li>
  <li><code class="language-plaintext highlighter-rouge">fields_for</code>を正しいパラメータで自動的に呼び出します。</li>
  <li>Stimulusコントローラーを設定します。</li>
  <li>追加/削除ボタンを適切な場所に配置することで、呼び出し元が表示するフィールドを簡単に定義できるようにします。</li>
</ul>

<p>このロジックを、アプリケーション内のすべてのStimulusコントローラー（フォーム内であってもそうでなくても）に適用することもでき、その結果、ビューの可読性がさらに向上するはずです。</p>

<h3 id="activerecordのアソシエーション">ActiveRecordのアソシエーション</h3>

<p>Railsでフォームを作成する際に頭を悩ませる問題を避ける鍵は、いくつかの概念を理解し、習得することです：</p>

<ul>
  <li>Rackのパラメータ形式（パラメータがどのようにオプションのハッシュとして渡されるか）。</li>
  <li>永続化された状態と非永続化された状態でのアソシエーション管理。Railsは、アソシエーションのグラフが永続化されているかどうかに関わらずナビゲートできる機能を持っています。しかし、両者の間には違いがあります。Railsの魔法にも限界があります。</li>
  <li>データベースのトランザクションシステムの理解が重要です。鍵は一つの簡単なルールにあります：一つのコントローラーアクション = 一回のsave。Railsでのsaveは、オブジェクトグラフ全体をトランザクションで保存することを可能にすることを理解することが重要です。トランザクションを手動でブロック管理する必要はなく、フォームをすべての関連オブジェクトを、それらのアソシエーションを介して保存するように構築する必要があるだけです。</li>
</ul>

<h2 id="activerecord内のアソシエーションの永続化">ActiveRecord内のアソシエーションの永続化</h2>

<p>フォームが期待通りに機能するためにどのように書かれるべきか理解するために、一般的に最初はRailsコンソールを探ります。</p>

<p>フォームで想定されるパラメータを持つ新しいオブジェクトを作成し、グラフをナビゲートし、保存し、すべてが期待通りに機能する場合は、フォームで使用される構造を複製します。</p>

<p>スコープを使用したより複雑なアソシエーションや<a href="https://edgeguides.rubyonrails.org/association_basics.html#polymorphic-associations">ポリモーフィックアソシエーション</a>を行う場合には、時折<a href="https://stackoverflow.com/questions/35104876/why-are-polymorphic-associations-not-supported-by-inverse-of">驚き</a>を伴うことがあります。</p>

<p>通常、これが実際の参考にならないことはめったにありませんが、時折、手動で設定しなければならないことがあります。</p>

<p>アソシエーションは可能な限りシンプルに保ってください。一部の組み合わせはRailsで正しく機能しない可能性があるためです。</p>

<p>以下のケースでは、アソシエーションがまだ保存されていない場合、逆の取得を許可しないことがわかります。これは容易に理解できることであり、スコープがDBクエリであるため保存されたアソシエーションでは実行されないためです。</p>

<p>すでに<code class="language-plaintext highlighter-rouge">has_many :items</code>があり、アイテムと同じクラスから<code class="language-plaintext highlighter-rouge">has_one :special_item, -&gt; { where(kind: :special) }</code>を追加したい場合、そのアソシエーションは保存されていないアソシエーションに対して正しく機能しません。これは特定の使用ケースで問題を引き起こすことがあります。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># アイテムとスペシャルアイテムを持つ新しいtodoを作成する</span>
<span class="o">&gt;</span>  <span class="n">todo</span> <span class="o">=</span> <span class="no">Todo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
     <span class="ss">items_attributes: </span><span class="p">[{}],</span>
     <span class="ss">special_item_attributes: </span><span class="p">{}</span>
   <span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Todo id: nil, name: nil&gt;</span>

<span class="c1"># アイテムは逆のアソシエーションを介してtodoにしっかりと関連付けられている</span>
<span class="o">&gt;</span>  <span class="n">todo</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">todo</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Todo id: nil, name: nil&gt;</span>

<span class="c1"># しかし、スペシャルアイテムは違う</span>
<span class="o">&gt;</span>  <span class="n">todo</span><span class="p">.</span><span class="nf">special_item</span><span class="p">.</span><span class="nf">todo</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>ActiveRecordの動作が期待通りにうまくいかない場合、そのアソシエーションを管理しているコードを確認し、問題の原因を理解する価値があります。</p>

<p>このような場合、私は<a href="https://ruby-doc.org/core-2.4.6/Method.html#method-i-source_location">source_location</a>を使って、アソシエーションコール中に使用されるコードを簡単に見つけます。このメソッドは、ソースファイルとメソッドが定義されている行番号を返します。例えば：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Todo</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:has_many</span><span class="p">).</span><span class="nf">source_location</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"gems/activerecord-7.2.1.1/lib/active_record/associations.rb"</span><span class="p">,</span> <span class="mi">1268</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="no">Todo</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="ss">:items</span><span class="p">).</span><span class="nf">source_location</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"gems/activerecord-7.2.1.1/lib/active_record/associations/builder/association.rb"</span><span class="p">,</span> <span class="mi">103</span><span class="p">]</span>
</code></pre></div></div>

<p>実装の詳細を理解することで、ActiveRecordと統合された機能を作成できます。それにより、アプリに自分自身の特殊な機能を追加でき、Railsの一部として存在するように見える機能を持つことが可能です。</p>

<h1 id="結論">結論</h1>

<p>Railsアプリケーションは複雑になることがあります。フレームワークの実用的なアプローチは時折、コードの組織上の問題を引き起こすことがあります。このような手法を使うことで、非常にシンプルで明確なビューとコントローラーを維持することができます。この問題はモデルの複雑さを管理する際にも存在しますが、私たちは次の機会にこの話題を取り上げることにします。</p>]]></content><author><name></name></author><category term="Rails" /><category term="ActionController" /><category term="ActionView" /><summary type="html"><![CDATA[はじめに]]></summary></entry><entry><title type="html">ActiveAdminでの非同期エクスポート</title><link href="/rails/activeadmin/2024/04/25/exports-csv-asynchrones-activeadmin.html" rel="alternate" type="text/html" title="ActiveAdminでの非同期エクスポート" /><published>2024-04-25T19:37:00+00:00</published><updated>2024-04-25T19:37:00+00:00</updated><id>/rails/activeadmin/2024/04/25/exports-csv-asynchrones-activeadmin</id><content type="html" xml:base="/rails/activeadmin/2024/04/25/exports-csv-asynchrones-activeadmin.html"><![CDATA[<h1 id="はじめに">はじめに</h1>

<p>データエクスポートはほとんどの企業アプリケーションに存在する機能です。ActiveAdmin はデフォルトでエクスポート機能を提供しており、この機能は同期的に動作します。つまり、データの生成はクライアントの要求時に行われます。</p>

<h1 id="同期エクスポートの問題">同期エクスポートの問題</h1>

<p>しかし、エクスポートするデータの量が多い場合、処理に時間がかかることがあります。サーバーが忙しくなると、それによって要求を処理できず、要求が積み重なり、ボトルネックが発生します。パフォーマンスが低下し、アプリケーションが遅いことにユーザーが気付きます。</p>

<p>状況が悪化すると、バックログが大きくなりすぎて、サーバーがリクエストをタイムリーに処理できなくなります。アプリケーションはエラーを返し始めます。状況がさらに悪化し続けると、アプリケーションは完全に機能しなくなり、アクセスできなくなります。</p>

<h1 id="非同期ソリューションの実装">非同期ソリューションの実装</h1>

<p>このような問題に直面した際、私たちは <a href="https://github.com/rootstrap/activeadmin-async_exporter"><code class="language-plaintext highlighter-rouge">activeadmin-async_exporter</code></a> というgemを使用して対処しました。このライブラリは、ActiveJobを使用してActiveAdminでデータエクスポートを非同期に行うことを可能にします。しかし、私たちはこのソリューションを利用するために調整を行う必要がありました。</p>

<p>まず、<code class="language-plaintext highlighter-rouge">activeadmin-async_exporter</code>というgemはその作者によってもはやメンテナンスされておらず、私たちのRailsのバージョンとは互換性がありませんでした。そのため、私たちはそれを修正し、その依存関係を更新する必要がありました。</p>

<p>さらに、strong_parametersを使用してパラメータを管理し、 <code class="language-plaintext highlighter-rouge">current_user</code> を使用する際に欠落するメソッドの問題を解決するためにいくつかの追加の適応を行いました。これは、作者のgemが <code class="language-plaintext highlighter-rouge">current_admin_user</code> を使用しているためです。</p>

<p>私たちのアプリケーションとは異なり、gemは添付ファイルにActiveStorageを使用していません。そのため、この部分も調整を行いました。</p>

<p>リクエストを記録するために、gemはデータベースに必要なテーブルを作成するマイグレーションのためのジェネレーターを提供します。また、エクスポートを管理するためのインターフェイス用のActiveAdminジェネレーターも提供します。ただし、これらのジェネレーターは文書化されていません。</p>

<p>最終的に、私たちはgemのコードをアプリケーションに直接取り込み、必要に応じてカスタマイズしました。</p>

<h1 id="gemとしての公開">gemとしての公開</h1>

<p>コードがアプリケーションに統合されているため、私たちはこれを新しいgemとして公開しないことに決めました。新たな適応努力が必要となるでしょう。また、このライブラリの活動が少ないことを考えると、このソリューションがコミュニティのニーズを必ずしも満たしているとは思えませんが、私たちのアプリケーションのパフォーマンスを向上させるのに非常に役立ちました。</p>

<p>それでも、これらの変更に興味がある場合や質問やコメントがある場合は、お気軽にお問い合わせください。</p>

<h1 id="結論">結論</h1>

<p>このエピソードは、アプリケーションの進化における問題がどのように発生するかを具体的な例で示しています。人気がなくメンテナンスされていないgemの使用と調整に基づくソリューションは一見非定型に見えるかもしれませんが、このアプローチは実際には技術的な問題解決の非常にクラシックなプロセスに従っています。</p>]]></content><author><name></name></author><category term="Rails" /><category term="ActiveAdmin" /><summary type="html"><![CDATA[はじめに]]></summary></entry></feed>